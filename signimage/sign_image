#! /bin/sh
# SPDX-License-Identifier: GPL-2.0-or-later
####################################################################################
#                                                                                  #
# sign a tar archive with our private RSA key                                      #
#                                                                                  #
# The key has to be generated with the right name (look at image_signing_files.inc #
# for the name components) and has to be reachable at the current working          #
# directory, if the "name_prefix" component does not contain a complete path       #
# (absolute or relative).                                                          #
#                                                                                  #
# The archive to sign may not contain a var/signature member, it would lead to     #
# a confusion in "firmwarecfg", if the hash is recomputed later for checking.      #
#                                                                                  #
# The signed image is written to STDOUT (it is created "on the fly" and will never #
# be stored by the script itself to save space, if the process runs on the target  #
# device) and the caller is responsible to redirect the output to the final        #
# destination.                                                                     #
#                                                                                  #
# To ensure proper archive handling, the input file must use the pure GNU tar      #
# format without PAXHEADERS and longer EoA headers.                                #
#                                                                                  #
####################################################################################
#                                                                                  #
# determine our script path to locate the include file                             #
#                                                                                  #
####################################################################################
my_path="$0"
[ "${my_path%/*}" = "$my_path" ] && my_path="." || my_path="${my_path%/*}"
my_name="${0##*/}"
box_key_name="/var/flash/websrv_ssl_key"
signature_file="./var/signature"
####################################################################################
#                                                                                  #
# include the common file definitions                                              #
#                                                                                  #
####################################################################################
. "$my_path/image_signing_files.inc"
####################################################################################
#                                                                                  #
# get the path for needed external commands, if called in any toolchain            #
#                                                                                  #
# looks a little bit complicated, but has to support definitions for BusyBox       #
# applets as commands to be used and simple quoting isn't enough to ensure proper  #
# substitution, but spreading 'eval' statements all over the code looks ugly, too  #
#                                                                                  #
####################################################################################
if ! [ -z "$YF_SIGNIMAGE_TAR" ]; then
	__YF_SIGNIMAGE_TAR="$YF_SIGNIMAGE_TAR"
	__yf_signimage_tar()
	{
		eval $__YF_SIGNIMAGE_TAR $*
	}
	YF_SIGNIMAGE_TAR="__yf_signimage_tar"
else
	YF_SIGNIMAGE_TAR="tar"
fi
if ! [ -z "$YF_SIGNIMAGE_DD" ]; then
	__YF_SIGNIMAGE_DD="$YF_SIGNIMAGE_DD"
	__yf_signimage_dd()
	{
		eval $__YF_SIGNIMAGE_DD $*
	}
	YF_SIGNIMAGE_DD="__yf_signimage_dd"
else
	YF_SIGNIMAGE_DD="dd"
fi
if ! [ -z "$YF_SIGNIMAGE_OPENSSL" ]; then
	__YF_SIGNIMAGE_OPENSSL="$YF_SIGNIMAGE_OPENSSL"
	__yf_signimage_openssl()
	{
		eval $__YF_SIGNIMAGE_OPENSSL $*
	}
	YF_SIGNIMAGE_OPENSSL="__yf_signimage_openssl"
else
	YF_SIGNIMAGE_OPENSSL="openssl"
fi
####################################################################################
#                                                                                  #
# some subfunctions                                                                #
#                                                                                  #
####################################################################################
show_error() ( printf "\033[1;31mFAILED\033[0m\a\n" 1>&2; )
show_ok() ( printf "\033[1;32mOK\033[0m\n" 1>&2; )
show_version()
(
	local v
	v=$("$YF_SIGNIMAGE_OPENSSL" version 2>/dev/null)
	if [ $? -eq 127 ]; then
		printf "\033[1;31mMissing \033[1;37mopenssl\033[1;31m binary, set \033[1;37mYF_SIGNIMAGE_OPENSSL\033[1;31m variable to its path name.\033[0m\a\n" 1>&2
		return 1
	else
		printf "Found \033[1;34m$v\033[0m\n" 1>&2
		return 0
	fi
)
__check_required_command()
(
	IFS=:
	set -- $1
	for n in $@; do
		command -v $n 2>/dev/null 1>&2 && exit 0
	done
	exit 1
)
__random()
(
	[ -f /proc/sys/kernel/random/uuid ] && cat /proc/sys/kernel/random/uuid && exit 0
	for h in md5sum sha1sum; do
		if __check_required_command $h; then
			if [ -c /dev/urandom ] && __check_required_command "dd"; then
				$YF_SIGNIMAGE_DD if=/dev/urandom bs=32 count=1 status=none 2>/dev/null | $h | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
			fi
			for f in /proc/self/stat /proc/self/status /proc/interrupts /proc/softirqs /proc/uptime; do
				if [ -f $f ]; then
					$h < $f | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
				fi
			done
		fi
	done
	__check_required_command "date" && date +%s && exit 0
	printf "%d" "$$"
)
__mktmp()
(
	if __check_required_command "mktemp"; then
		n="$(mktemp $* 2>/dev/null)"
	fi
	if [ -z "$n" ]; then
		t="${TMPDIR:-/tmp}"
		[ "$1" = "-d" ] && d=1 || d=0
		[ "$1" = "-p" ] && t="$2"
		[ -z "$t" ] && t="/tmp"
		n="$t/$(__random)"
		if [ $d -eq 1 ]; then
			[ -d "$n" ] && n="$t/$(__random)"
			mkdir -p "$n" 2>/dev/null
		else
			while [ -e "$n" ]; do
				n="$t/$(__random)"
			done
			touch "$n" 2>/dev/null
		fi
	fi
	printf "$n"
)
__read_password()
(
	printf "$1" 1>&2
	read password
	# printf "\n" 1>&2
	printf "%s\n" "$password"
)
####################################################################################
#                                                                                  #
# usage screen, caller has to redirect output to STDERR if needed                  #
#                                                                                  #
####################################################################################
usage()
(
	printf "\033[1mSign a tar archive file as firmware image for FRITZ!OS devices.\033[0m\n\n"
	printf "Usage:\n\n"
	printf "$0 \033[1mimagefile\033[0m [\033[1mpassword\033[0m]\n\n"
	printf "\033[1mimagefile\033[0m is the archive to sign, there must be no \033[1mvar/signature\033[0m file\n"
	printf "embedded yet.\n\n"
	printf "The \033[1mpassword\033[0m will be read from the terminal, if it's not specified.\n"
	printf "The signed image is written to STDOUT, you should redirect it to the proper target file location.\n\n"
	printf "The default hash algorithm used is MD5, as it's used by the current\n"
	printf "AVM implementation. If you know for sure, that you will only use non-\n"
	printf "AVM scripts/components to sign and verify, you may specify a better\n"
	printf "hash algorithm (remember that the openssl binary still has to support\n"
	printf "it) with an environment variable USEHASH specifying the name of the\n"
	printf "algorithm to use.\n"
	printf "A special use case is the signing of a TAR file directly in a FRITZ!OS\n"
	printf "environment, if such a signature is surely checked later only on the\n"
	printf "same device. Then we may use the RSA key from \033[1mwebsrv_ssl_key.pem\033[0m\n"
	printf "instead of an additional key and we don't need to specify its\n"
	printf "password, because it may be read with \033[1mprivatekeypassword\033[0m. To switch\n"
	printf "this script into this 'internal-\only mode', set the environment\n"
	printf "variable SIGN_ON_BOX to '1' while calling it. Be aware, that a key\n"
	printf "size other than 1024 bits would lead to the impossibility to verify\n"
	printf "the signed file with AVM components.\n"
)
####################################################################################
#                                                                                  #
# compute checksum of a TAR header                                                 #
#                                                                                  #
####################################################################################
checksum()
(
	read_values()
	{
		while read pos left right; do
			sum=$(( sum + 0$left ))
		done
		printf "%d" $sum
	}
	sum=0
	cmp -l -- "$1" /dev/zero 2>/dev/null | read_values
)
####################################################################################
#                                                                                  #
# try to identify FRITZ!OS as runtime environment (not too sophisticated, but it   #
# should be able to make this distinction)                                         #
#                                                                                  #
####################################################################################
is_fritzos_environment()
(
	eva_prompt="Eva_AVM"
	[ ${#HWRevision} -eq 0 ] && exit 1
	[ ${#CONFIG_ENVIRONMENT_PATH} -eq 0 ] && exit 1
	[ -d "$CONFIG_ENVIRONMENT_PATH" ] || exit 1
	[ -f "$CONFIG_ENVIRONMENT_PATH/environment" ] || exit 1
	HWRev="$(sed -n -e "s|^HWRevision\t\(.*\)\$|\1|p" $CONFIG_ENVIRONMENT_PATH/environment)"
	[ ${#HWRev} -eq 0 ] && exit 1
	if [ "$HWRev" != "$HWRevision" ]; then
		if [ -z "$YF_SIGNIMAGE_IGNORE_HWREVISION" ]; then
			printf "\033[1;31mMismatch of \033[1;37mHWRevision\033[1;31m between shell and urlader environment (\033[1;37m%s\033[1;31m vs. \033[1;37m%s\033[1;31m).\033[0m\a\n" "$HWRev" "$HWRevision" 1>&2
			exit 1
		fi
		printf "\033[1;37mHWRevision\033[1;33m mismatch between shell and urlader environment (\033[1;37m%s\033[1;33m vs. \033[1;37m%s\033[1;33m) ignored.\033[0m\n" "$HWRev" "$HWRevision" 1>&2
	fi
	prompt="$(sed -n -e "s|^prompt\t\(.*\)\$|\1|p" $CONFIG_ENVIRONMENT_PATH/environment)"
	[ ${#prompt} -eq 0 ] && exit 1
	[ "$prompt" != "$eva_prompt" ] && exit 1
	exit 0
)
####################################################################################
#                                                                                  #
# check parameters                                                                 #
#                                                                                  #
####################################################################################
if [ -z "$1" ]; then
		usage 1>&2
		exit 1
else
	image_file="$1"
fi
if ! [ -f "$image_file" ]; then
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m does not exist.\033[0m\a\n" "$image_file" 1>&2
	exit 1
fi
if [ -t 1 ]; then
	printf "\033[1;31mThe output stream is a terminal device, please redirect output to a file.\033[0m\a\n" 1>&2
	exit 1
fi
####################################################################################
#                                                                                  #
# check OpenSSL presence and version                                               #
#                                                                                  #
####################################################################################
show_version
[ $? -ne 0 ] && exit 1
printf "Check \033[1mdgst\033[0m command ... " 1>&2
printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst 2>&1 | grep -q '^(stdin)=' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok
else
	show_error
	exit 1
fi
printf "Check \033[1mrsa\033[0m command ... " 1>&2
printf "" | "$YF_SIGNIMAGE_OPENSSL" rsa 2>&1 | grep -q '^unable to load' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok
else
	show_error
	exit 1
fi
####################################################################################
#                                                                                  #
# check the specified hash algorithm and verify, it's provided by the openssl      #
# binary                                                                           #
#                                                                                  #
####################################################################################
if [ "${#USEHASH}" -gt 0 ]; then
	check_algo="$(printf "%s\n" "$USEHASH" | sed -e "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/")"
	hash_algo=""
	for algo in md5 sha1 sha224 sha256 sha384 sha512 whirlpool; do
		if [ "$algo" = "$check_algo" ]; then
			hash_algo=$algo
			break
		fi
	done
	if [ "${#hash_algo}" -eq 0 ]; then
		printf "\033[1;31mUnknown or unsupported (by this script) hash algorithm \033[1;37m$USEHASH\033[1;31m specified.\033[0m\a\n" 1>&2
		exit 1
	fi
else
	hash_algo="md5"
fi
printf "Verify hash algorithm \033[1m$hash_algo\033[0m is supported ... " 1>&2
printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst -$hash_algo 2>&1 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok
else
	show_error
	exit 1
fi
####################################################################################
#                                                                                  #
# use 'force-local' option with GNU TAR, if the image name contains a colon        #
#                                                                                  #
####################################################################################
if [ -n "$(expr "$image_file" : ".*\(:\).*")" ]; then
	"$YF_SIGNIMAGE_TAR" --help 2>&1 | grep -q 'force-local' 2>/dev/null && force_local="--force-local"
else
	force_local=""
fi
####################################################################################
#                                                                                  #
# verify input file format                                                         #
#                                                                                  #
####################################################################################
printf "Checking input file format ... " 1>&2
"$YF_SIGNIMAGE_DD" if="$image_file" bs=1 skip=257 count=5 status=none 2>/dev/null | grep -q "^ustar\$" 2>/dev/null
if [ $? -ne 0 ]; then
	show_error
	printf "\033[1;31mInput file doesn't look like a TAR archive.\033[0m\a\n" 1>&2
	exit 1
fi
"$YF_SIGNIMAGE_DD" if="$image_file" bs=100 count=1 status=none 2>/dev/null | grep -q "PaxHeaders" 2>/dev/null
if [ $? -eq 0 ]; then
	show_error
	printf "\033[1;31mInput file contains extended headers (PaxHeaders) and may not be signed this way.\033[0m\a\n" 1>&2
	exit 1
fi
####################################################################################
#                                                                                  #
# check first archive member (name=./var/, type=directory)                         #
#                                                                                  #
####################################################################################
if ! [ "$("$YF_SIGNIMAGE_DD" if="$image_file" bs=1 count=7 2>/dev/null | base64)" = "Li92YXIvAA==" ] || \
   ! [ "$("$YF_SIGNIMAGE_DD" if="$image_file" bs=1 count=1 skip=156 2>/dev/null)" = "5" ]; then
	show_error
	printf "\033[1;31mFirst member of archive file has to be a directory and has to use the name '\033[1;37m./var/\033[1;31m'.\033[0m\a\n" 1>&2
	exit 1
fi
####################################################################################
#                                                                                  #
# prepare a temporary directory and cleanup on exit                                #
#                                                                                  #
####################################################################################
tmp=$(__mktmp -d)
[ $? -eq 127 ] && tmp="/tmp/tmp.$(date +%s).$$" && mkdir -p "$tmp"
trap "rm -r \"$tmp\"" EXIT HUP
####################################################################################
#                                                                                  #
# check end of archive headers, GNU tar writes more than needed                    #
#                                                                                  #
####################################################################################
offset=0
"$YF_SIGNIMAGE_TAR" -t -v -f "$image_file" $force_local |
sed -n -e "s|^[^ ]* *[^ ]* *\([0-9]*\) *[^ ]* *[^ ]* *\(.*\)\$|SIZE=\1 MEMBER=\"\2\"|p" |
while read line; do
	eval $line
	file_offset="$offset"
	file_start="$(( file_offset + 512 ))"
	file_end="$(( file_start + SIZE ))"
	offset="$(( ( ( file_end + 511 ) / 512 ) * 512 ))"
	printf "HEADER=%u START=%u END=%u SIZE=%u BLOCKS=%u MEMBER=\"%s\"\n" "$file_offset" "$file_start" "$file_end" "$SIZE" "$(( ( offset - file_offset ) / 512 ))" "$MEMBER" >>"$tmp/image_members"
done
copy_blocks=0
while read line; do
	i=$(( i + 1 ))
	eval $line
	copy_blocks="$(( copy_blocks + BLOCKS ))"
	if [ "$MEMBER" = "$signature_file" ]; then
		show_error
		printf "\033[1;31mThe input file already contains a member '\033[1;37m%s\033[1;31m' and may not be signed (again) by this script.\033[0m\a\n" "$signature_file" 1>&2
		exit 1
	fi
done <"$tmp/image_members"
file_size="$(cat "$image_file" | wc -c)"
file_blocks=$(( file_size / 512 ))
eoa_blocks=$(( file_blocks - copy_blocks ))
show_ok
if [ $eoa_blocks -gt 2 ]; then
	printf "\033[1;33mThe end of archive markers at the input file are too large\033[0m: blocks expected=\033[1m%u\033[0m, blocks present=\033[1m%u\033[0m.\n\033[1;33mThe input file will be truncated after the last archive member.\033[0m\n" "2" "$eoa_blocks" 1>&2
fi
####################################################################################
#                                                                                  #
# check the special case of signing on the FRITZ!Box with the internal key         #
#                                                                                  #
####################################################################################
on_box=0
if [ ${#SIGN_ON_BOX} -gt 0 ]; then
	if [ "$SIGN_ON_BOX" = "1" ]; then
		if ! is_fritzos_environment; then
			printf "\033[1;31mThe special mode - to sign an image with the RSA key from a device - may only be used in a FRITZ!OS environment.\033[0m\n" 1>&2
			exit 1
		else
			if ! __check_required_command "privatekeypassword"; then
				printf "\033[1;31mThe \033[1;37mprivatekeypassword\033[1;31m executable is missing.\033[0m\a\n" 1>&2
				exit 1
			else
				KEYPASSWORD="$(privatekeypassword 2>/dev/null)"
				if [ ${#KEYPASSWORD} -eq 0 ]; then
					printf "\033[1;31mError determining the password of RSA key from FRITZ!OS.\033[0m\a\n" 1>&2
					exit 1
				else
					name_prefix="$box_key_name"
					private_extension="pem"
					on_box=1
				fi
			fi
		fi
	fi
fi
####################################################################################
#                                                                                  #
# get the password for the private key, if needed                                  #
#                                                                                  #
####################################################################################
if [ $on_box -eq 0 ]; then
	if [ -z "$2" ]; then
		if ! [ -t 0 ]; then
			usage 1>&2
			exit 1
		else
			if [ "${#YF_SIGNIMAGE_KEYPASSWORD}" -eq 0 ]; then
				KEYPASSWORD="$(__read_password "\033[1;34mEnter your password for the signing key: \033[0m")"
			else
				KEYPASSWORD="$YF_SIGNIMAGE_KEYPASSWORD"
			fi
		fi
	else
		KEYPASSWORD="$2"
	fi
fi
####################################################################################
#                                                                                  #
# check key password first (and key file presence)                                 #
#                                                                                  #
####################################################################################
if [ $on_box -eq 0 ]; then
	printf "Check the password for the private key file ... " 1>&2
	"$YF_SIGNIMAGE_OPENSSL" rsa -in "${name_prefix}.${private_extension}" -noout -passin "pass:$KEYPASSWORD" 2>/dev/null 1>&2
	rc=$?
	if [ $rc -eq 0 ]; then
		show_ok
	else
		show_error
		exit 1
	fi
fi
####################################################################################
#                                                                                  #
# create a subdirectory 'var' to prepare a TAR file of our signature later         #
#                                                                                  #
####################################################################################
mkdir -p "$tmp/var"
####################################################################################
#                                                                                  #
# prepare a temporary block as filler, if circumvention of AVM's hash error is     #
# needed                                                                           #
#                                                                                  #
####################################################################################
rm -f "$tmp/filler.bin"
touch "$tmp/filler.bin"
if [ -z "$YF_SIGNIMAGE_SKIP_WORKAROUNDS" ]; then
	if [ $(( ( copy_blocks + 2 ) % 20 )) -eq 0 ]; then
		printf "\033[1;33mRepeating first entry once as filler ... \033[0m" 1>&2
		"$YF_SIGNIMAGE_DD" if="$image_file" of="$tmp/filler.bin" bs=512 count=1 status=none 2>/dev/null
		show_ok
	elif [ $(( ( copy_blocks + 3 ) % 20 )) -eq 0 ]; then
		printf "\033[1;33mRepeating first entry two times as filler ...\033[0m" 1>&2
		( "$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=1 status=none 2>/dev/null;
		"$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=1 status=none 2>/dev/null ) >"$tmp/filler.bin"
		show_ok
	fi
fi
####################################################################################
#                                                                                  #
# prepare a temporary block for an empty TAR member - 512 byte header and 512 byte #
# content, it will be used as "end of archive" header too (2 continous empty       #
# blocks with a size of 512 octets)                                                #
#                                                                                  #
####################################################################################
"$YF_SIGNIMAGE_DD" if=/dev/zero of="$tmp/1K.bin" bs=512 count=2 status=none 2>/dev/null
####################################################################################
#                                                                                  #
# generate the signature file                                                      #
#                                                                                  #
# - the input file will be combined with another 1 KB containing zeros             #
# - any superfluous blocks at the end of the archive are truncated                 #
# - the original EoA entry will be replaced with an empty 1K block for the sig     #
# - an additional 1K block of zeros serves as new EoA header                       #
#                                                                                  #
##################################A#################################################
printf "Signing the image hash (\033[1m$hash_algo\033[0m) with RSA key from \033[1m${name_prefix}.${private_extension}\033[0m ... " 1>&2
"$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=$copy_blocks status=none 2>&1 | cat - "$tmp/filler.bin" "$tmp/1K.bin" "$tmp/1K.bin" |
"$YF_SIGNIMAGE_OPENSSL" dgst -$hash_algo -sign "${name_prefix}.${private_extension}" -out "$tmp/$signature_file" -passin "pass:$KEYPASSWORD"
rc=$?
if [ $rc -eq 0 ]; then
	show_ok
	sigsize="$(cat "$tmp/$signature_file" | wc -c)"
else
	show_error
	exit 1
fi
####################################################################################
#                                                                                  #
# stream the shortened image file (without EoA) to STDOUT                          #
#                                                                                  #
####################################################################################
printf "Copying resulting image to output ... " 1>&2
"$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=$copy_blocks status=none
cat "$tmp/filler.bin"
####################################################################################
#                                                                                  #
# build our own signature member using the first member entry from image           #
#                                                                                  #
####################################################################################
"$YF_SIGNIMAGE_DD" if="$image_file" of="$tmp/header" bs=512 count=1 status=none 2>/dev/null
printf "%s" "${signature_file##*/}" | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=6 conv=notrunc status=none 2>/dev/null
printf "%04o\000" $sigsize | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=131 conv=notrunc status=none 2>/dev/null
printf "0" | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=156 conv=notrunc status=none 2>/dev/null
printf "        " | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=148 conv=notrunc status=none 2>/dev/null
chksum=$(checksum "$tmp/header")
printf "%06o\000" $chksum  | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=148 conv=notrunc status=none 2>/dev/null
####################################################################################
#                                                                                  #
# and append signature content and EoA blocks                                      #
#                                                                                  #
####################################################################################
cat "$tmp/header" "$tmp/$signature_file"
"$YF_SIGNIMAGE_DD" if=/dev/zero bs=$(( 512 - sigsize )) count=1 status=none 2>/dev/null
cat "$tmp/1K.bin"
show_ok
####################################################################################
#                                                                                  #
# all done, now STDOUT has seen all the needed data to be used as a signed image   #
#                                                                                  #
####################################################################################
exit 0
####################################################################################
#                                                                                  #
# end of file                                                                      #
#                                                                                  #
####################################################################################
