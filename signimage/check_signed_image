#! /bin/sh
# SPDX-License-Identifier: GPL-2.0-or-later
####################################################################################
#                                                                                  #
# check, if the specified image contains an AVM-like signature and if it is signed #
# with a key from the specified list of possible public key files (the public keys #
# may be specified/used in various format, please read the usage output carefully) #
#                                                                                  #
# The result of this check is written to STDERR and the return code is set to one  #
# of the values below:                                                             #
#                                                                                  #
#   0 - verification successful                                                    #
#   1 - invalid arguments on command line                                          #
#   2 - missing arguments                                                          #
#   3 - specified image file not found                                             #
#   4 - the image file contains no "./var/signature" member                        #
#   5 - the signature file has a wrong size                                        #
#   6 - the specified file does not exist                                          #
#   7 - no usable public key found                                                 #
#   8 - the signature file contains no ASN.1 structure                             #
#   9 - the signature file uses an unsupported hash algorithm (not used anymore)   #
#  10 - the hash algorithm used to sign isn't supported by the openssl binary      #
#  11 - none of the specified public key sources was able to provide a key         #
#  12 - a specified file contains invalid data                                     #
#  13 - the builtin key files from FRITZ!OS (option -b) can only be used, if we're #
#       running in the correct environment (or a valid emulation of such one)      #
#  14 - unable to read the FRITZ!OS RSA key from /var/flash                        #
#  32 - "openssl" binary not found                                                 #
#  33 - "openssl" function "dgst" is not available                                 #
#  34 - "openssl" function "rsautl" is not available                               #
#  35 - "openssl" function "x509" is needed and not available                      #
#  64 - signature verification failed                                              #
#                                                                                  #
####################################################################################
#                                                                                  #
# constants                                                                        #
#                                                                                  #
####################################################################################
avm_default_files="/etc/avm_firmware_public_key[1-9] plugin_global_key.pem"
eva_prompt="Eva_AVM"
box_key_name="/var/flash/websrv_ssl_key.pem"
box_cert_name1="/var/flash/websrv_ssl_cert.pem"
box_cert_name2="/var/tmp/websrv_ssl_cert.pem"
signature_file="./var/signature"
####################################################################################
#                                                                                  #
# some subfunctions                                                                #
#                                                                                  #
####################################################################################
show_error() ( printf "\033[1;31mFAILED\033[0m\a\n" 1>&2; )
show_ok() ( printf "\033[1;32mOK\033[0m\n" 1>&2; )
show_version()
(
	version=$("$YF_SIGNIMAGE_OPENSSL" version 2>/dev/null)
	if [ $? -eq 127 ]; then
		printf "\033[1;31mMissing \033[1;37mopenssl\033[1;31m binary, set \033[1;37mYF_SIGNIMAGE_OPENSSL\033[1;31m variable to its path name.\033[0m\a\n" 1>&2
		exit 1
	else
		printf "Found \033[1;34m%s\033[0m\n" "$version" 1>&2
		exit 0
	fi
)
__check_required_command()
(
	IFS=:
	set -- "$1"
	for n in "$@"; do
		command -v "$n" 2>/dev/null 1>&2 && exit 0
	done
	exit 1
)
__random()
(
	[ -f /proc/sys/kernel/random/uuid ] && cat /proc/sys/kernel/random/uuid && exit 0
	for h in md5sum sha1sum; do
		if __check_required_command $h; then
			if [ -c /dev/urandom ] && __check_required_command "dd"; then
				$YF_SIGNIMAGE_DD if=/dev/urandom bs=32 count=1 status=none 2>/dev/null | $h | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
			fi
			for f in /proc/self/stat /proc/self/status /proc/interrupts /proc/softirqs /proc/uptime; do
				if [ -f $f ]; then
					$h < $f | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
				fi
			done
		fi
	done
	__check_required_command "date" && date +%s && exit 0
	printf "%d" "$$"
)
__mktmp()
(
	if __check_required_command "mktemp"; then
		n="$(mktemp "$@" 2>/dev/null)"
	fi
	if [ -z "$n" ]; then
		t="${TMPDIR:-/tmp}"
		[ "$1" = "-d" ] && d=1 || d=0
		[ "$1" = "-p" ] && t="$2"
		[ -z "$t" ] && t="/tmp"
		n="$t/$(__random)"
		if [ $d -eq 1 ]; then
			[ -d "$n" ] && n="$t/$(__random)"
			mkdir -p "$n" 2>/dev/null
		else
			while [ -e "$n" ]; do
				n="$t/$(__random)"
			done
			touch "$n" 2>/dev/null
		fi
	fi
	printf "%s\n" "$n"
)
__hex2bin()
(
	__hex2bin_read_octal()
	{
		i=1
		h=1
		z=0
		# shellcheck disable=SC2162
		while read p l o; do
			[ "$i" -lt "$p" ] && return 1 # zero bytes on input stream are an error
			i=$(( i + 1 ))
			if [ "$o" -eq 11 ] || [ "$o" -eq 12 ] || [ "$o" -eq 15 ] || [ "$o" -eq 40 ]; then
				[ $h -eq 1 ] && continue || return 1 # whitespace after odd hex-digits
			fi
			if [ "$o" -ge 60 ] && [ "$o" -le 67 ]; then
				c=$(( o - 60 ))
			elif [ "$o" -ge 70 ] && [ "$o" -le 71 ]; then
				c=$(( o - 62 ))
			elif [ "$o" -ge 101 ] && [ "$o" -le 106 ]; then
				c=$(( o - 91 ))
			elif [ "$o" -ge 141 ] && [ "$o" -le 146 ]; then
				c=$(( o - 131 ))
			else
				return 1 # invalid character found
			fi
			if [ $h -eq 0 ]; then
				v=$(( v + c ))
				if [ $v -eq 0 ]; then
					z=$(( z + 1 )) # count consecutive zeros
				else
					if [ $z -gt 0 ]; then
						dd if=/dev/zero bs=$z count=1 2>/dev/null
						z=0
					fi
					printf "%b" "\0$(( v >> 6 ))$(( ( v >> 3 ) & 7 ))$(( v & 7 ))"
				fi
				h=1
			else
				v=$(( c * 16 ))
				h=0
			fi
		done
		[ $z -gt 0 ] && dd if=/dev/zero bs="$z" count=1 2>/dev/null
		return 0
	}

	command -v cmp 2>/dev/null 1>&2 || return 1
	command cmp -l -- /dev/zero - 2>/dev/null | __hex2bin_read_octal
	return $?
)
####################################################################################
#                                                                                  #
# usage screen, caller has to redirect output to STDERR if needed                  #
#                                                                                  #
####################################################################################
usage()
(
	printf    "\033[1mCheck, whether signature of the specified image file is valid.\033[0m\n\n"
	printf    "Usage:\n\n"
	printf    "%s \033[1mimagefile\033[0m \033[1;34mpublic_keys\033[0m\n\n" "$0"
	printf    "\033[1mimagefile\033[0m is the archive to check and the list of public keys to consider\n"
	printf    "for decryption (the \033[1;34mpublic_keys\033[0m part above) may be built from the following\n"
	printf    "sources:\n\n"
	printf -- "-f \033[1mfilename\033[0m - add the file names in the specified file\n"
	printf -- "-b          - add the key files from the current OS to the list, this option\n"
	printf    "              makes only sense, if the script is executed on a FRITZ!OS-based\n"
	printf    "              device or in a proper emulation; an existing plugin signing key\n"
	printf    "              is also affected by this option\n"
	printf -- "-c \033[1mfilename\033[0m - add raw lines from the specified file to the list,\n"
	printf    "              each line needs a MOD and EXP value (if the used exponent\n"
	printf    "              isn't the default 0x010001), SRC (optional) as a pseudo\n"
	printf    "              filename and DESC (optional, too) as a description to be\n"
	printf    "              displayed for this key (unused yet)\n"
	printf -- "-a \033[1mfilename\033[0m - add the specified file (AVM text format) to the list\n"
	printf -- "-p \033[1mfilename\033[0m - add the specified file (PEM format) to the list\n"
	printf -- "-d \033[1mfilename\033[0m - add the specified file (DER format) to the list\n"
	printf -- "-s          - check, that the image file was signed with the RSA key from\n"
	printf    "              the box where we're running on (cannot be combined with other\n"
	printf    "              key sources)\n\n"
	printf    "The first key from the specified sources (which are probed in the\n"
	printf    "given order) able to decode the signature file will be used for\n"
	printf    "signature verification.\n\n"
	printf    "Remark:\n"
	printf    "If you have an image file not signed by AVM, it may use better hash\n"
	printf    "algorithms from a limited set (md5, sha1, sha224, sha256, sha512,\n"
	printf    "whirlpool), as long as the openssl binary supports this algorithm.\n"
	printf    "The algorithm used to create the signature (by the signer) is detected\n"
	printf    "while decoding the signature file in a first step (its format will be\n"
	printf    "checked too in this step).\n\n"
	printf    "\033[1;31mWARNING:\033[0m\n"
	printf    "Because the lines from a 'raw file' (used with option 'c') are read\n"
	printf    "and simply 'eval'uated as commands (leading to assignments for the\n"
	printf    "values on each line), NEVER use this option with an input file from\n"
	printf    "an untrusted source or check the content thoroughly, before you use\n"
	printf    "it with this script.\n"
)
####################################################################################
#                                                                                  #
# try to identify FRITZ!OS as runtime environment (not too sophisticated, but it   #
# should be able to make this distinction)                                         #
#                                                                                  #
# The FRITZ!OS will be identified by looking for the environment variables:        #
# HWRevision, CONFIG_ENVIRONMENT_PATH                                              #
# If these values exist, the content of $CONFIG_ENVIRONMENT_PATH/environment is    #
# searched for the value of HWRevision again, it is compared to the value from OS  #
# environment and finally the content of 'prompt' is checked for 'Eva_AVM'         #
#                                                                                  #
####################################################################################
is_fritzos_environment()
(
	eva_prompt="Eva_AVM"
	# shellcheck disable=SC2154
	[ ${#HWRevision} -eq 0 ] && exit 1
	[ ${#CONFIG_ENVIRONMENT_PATH} -eq 0 ] && exit 1
	[ -d "$CONFIG_ENVIRONMENT_PATH" ] || exit 1
	[ -f "$CONFIG_ENVIRONMENT_PATH/environment" ] || exit 1
	HWRev="$(sed -n -e "s|^HWRevision\t\(.*\)\$|\1|p" "$CONFIG_ENVIRONMENT_PATH/environment")"
	[ ${#HWRev} -eq 0 ] && exit 1
	if [ "$HWRev" != "$HWRevision" ]; then
		if [ -z "$YF_SIGNIMAGE_IGNORE_HWREVISION" ]; then
			printf "\033[1;31mMismatch of \033[1;37mHWRevision\033[1;31m between shell and urlader environment (\033[1;37m%s\033[1;31m vs. \033[1;37m%s\033[1;31m).\033[0m\a\n" "$HWRev" "$HWRevision" 1>&2
			exit 1
		fi
		printf "\033[1;37mHWRevision\033[1;33m mismatch between shell and urlader environment (\033[1;37m%s\033[1;33m vs. \033[1;37m%s\033[1;33m) ignored.\033[0m\n" "$HWRev" "$HWRevision" 1>&2
	fi
	prompt="$(sed -n -e "s|^prompt\t\(.*\)\$|\1|p" "$CONFIG_ENVIRONMENT_PATH/environment")"
	[ ${#prompt} -eq 0 ] && exit 1
	[ "$prompt" != "$eva_prompt" ] && exit 1
	exit 0
)
####################################################################################
#                                                                                  #
# output the lines to use the builtin keys from the FRITZ!OS system, this script   #
# is running on - any further search will be skipped, if the environment does not  #
# match the usual characteristics of a FRITZ!Box router or a FRITZ!Repeater device #
#                                                                                  #
####################################################################################
builtin_keys()
(
	is_fritzos_environment || exit 13
	for f in $avm_default_files; do
		if [ -f "$f" ]; then
			mod=$(sed -n -e "1p" "$f")
			exp=$(sed -n -e "2p" "$f")
			[ ${#exp} -eq 0 ] && exp=010001
			printf "DESC=\"current system\" SRC=\"%s\" MOD=%s EXP=%s\n" "$f" "$mod" "$exp" >>"$tmp/public_keys"
		fi
	done
	exit 0
)
####################################################################################
#                                                                                  #
# output the modulus from the RSA key in /var/flash/websrv_ssl_key.pem to the list #
#                                                                                  #
# We'll try to extract the modulus from the private key first, if we cannot read   #
# this key due to missing or wrong password, we'll extract it from the X.509       #
# certificate in /var/flash or /var/tmp.                                           #
#                                                                                  #
####################################################################################
read_box_key()
(
	if __check_required_command "privatekeypassword"; then
		printf "Trying to read public key from FRITZ!OS private key file (\033[1m%s\033[0m) ... " "$box_key_name" 1>&2
		if "$YF_SIGNIMAGE_OPENSSL" rsa -in $box_key_name -pubout -passin pass:"$(privatekeypassword)" -out "$tmp/pubkey" 2>/dev/null; then
			read_openssl_file "$tmp/pubkey" PEM "box key" "FRITZ!OS RSA key" && show_ok && exit 0
		fi
		show_error
	fi
	# try to use the certificate to get the public key
	printf "Check \033[1mx509\033[0m command ... " 1>&2
	if printf "" | "$YF_SIGNIMAGE_OPENSSL" x509 2>&1 | grep -q '^unable to load certificate' 2>/dev/null 1>&2; then
		show_ok
	else
		show_error
		exit 35
	fi
	printf "Trying to read public key from \033[1m%s\033[0m ... " "$box_cert_name1" 1>&2
	if ! "$YF_SIGNIMAGE_OPENSSL" x509 -in "$box_cert_name1" -pubkey -noout >"$tmp/pubkey" 2>/dev/null; then
		show_error
		printf "Trying to read public key from \033[1m%s\033[0m ... " "$box_cert_name2" 1>&2
		if ! "$YF_SIGNIMAGE_OPENSSL" x509 -in "$box_cert_name2" -pubkey -noout >"$tmp/pubkey" 2>/dev/null; then
			show_error
			exit 14
		else
			show_ok
		fi
	else
		show_ok
	fi
	read_openssl_file "$tmp/pubkey" PEM "box certificate" "FRITZ!OS certificate"
	exit $?
)
####################################################################################
#                                                                                  #
# helper to convert from hexadecimal dumped modulus to DER format, look at         #
# avm_pubkey_to_pkcs8 for a version with comments                                  #
#                                                                                  #
####################################################################################
modulus_to_der()
(
	mod="$1"
	exp="${2:-010001}"
	t_int=02
	t_seq=30
	t_bstr=03
	t_oid=06
	t_null=0500

	asn1_len()
	{
		x()
		{
			v=$1
			l=$(printf "%x" "$v")
			[ $(( ${#l} % 2 )) -ne 0 ] && l="0$l"
			printf "%s" "$l"
		}

		l=0
		v=$1
		l=$(( ${#v} / 2 ))
		if [ $l -gt 127 ]; then
			i=$(x $l)
			l=$(( ( ${#i} / 2 ) + 128 ))
			printf "%s" "$(x $l)$i"
		else
			printf "%s" "$(x $l)"
		fi
	}

	m_len="$t_int$(asn1_len "$mod")"
	e_len="$t_int$(asn1_len "$exp")"
	pk_c="$m_len$mod$e_len$exp"
	pk_len="$(asn1_len "$pk_c")"
	pk_seq="$t_seq$pk_len$pk_c"
	pk_bit="00$pk_seq"
	bits="$t_bstr$(asn1_len "$pk_bit")$pk_bit"
	oid="2A864886F70D010101"
	o_enc="$t_oid$(asn1_len "$oid")$oid"
	o_alg="$o_enc$t_null"
	o_seq="$t_seq$(asn1_len "$o_alg")$o_alg"
	der="$t_seq$(asn1_len "$o_seq$bits")"
	res="$der$o_seq$bits"
	printf "%s" "$res" | __hex2bin
	return $?
)
####################################################################################
#                                                                                  #
# helper to convert from openssl public key format (PEM or DER) to intermediate    #
# text format ... it's an unnecessary conversion, but it makes handling easier, if #
# we 'normalize' such keys to the intermediate format, even if the final format is #
# the original again while calling openssl binary                                  #
#                                                                                  #
####################################################################################
read_openssl_file()
(
	read_error() ( printf "\033[1;31mUnable to read RSA key (%s) from input file \033[1;37m%s\033[1;31m.\033[0m\a\n" "$format" "$file" 1>&2; )

	file="$1"
	format="$2"
	DESC="${3:-$format key}"
	# shellcheck disable=SC2030
	SRC="${4:-$file}"
	line="$("$YF_SIGNIMAGE_OPENSSL" rsa -in "$file" -pubin -inform "$format" -modulus -noout 2>/dev/null)"
	rc=$?
	if [ $rc -ne 0 ]; then
		read_error
		exit 12
	else
		MOD="$(printf "%s\n" "$line" | sed -n -e "s|^Modulus=\(.*\)|\1|p" | sed -e "y/ABCDEF/abcdef/")"
		if [ ${#MOD} -eq 0 ]; then
			read_error
			exit 12
		fi
	 	expr "$MOD" : "\([89a-f]\).*" 2>/dev/null 1>&2 && MOD="00$MOD"
		if ! "$YF_SIGNIMAGE_OPENSSL" rsa -in "$file" -pubin -inform "$format" -text -noout 2>/dev/null | \
		   grep -q "^Exponent: 65537 (0x10001)\$" 2>/dev/null 1>&2; then # different exponent, read it from the output
			EXP=$("$YF_SIGNIMAGE_OPENSSL" rsa -in "$file" -pubin -inform "$format" -text -noout | \
				   sed -n -e "s|^Exponent: [0-9]* (\(0x[0-9a-fA-F]*\))\$|\1|p")
			if [ ${#EXP} -eq 0 ]; then
				printf "\033[1;31mUnexpected output while reading exponent from public key file \033[1;37m%s\033[1;31m (%s).\033[0m\a\n" "$file" "$format" 1>&2
				exit 12
			fi
			EXP="$(printf "%016x" "$(( EXP ))")"
			while [ "$(expr "$EXP" : "\(.\).*")" = "0" ]; do
				EXP="$(expr "$EXP" : ".\(.*\)")"
			done
			[ $(( ${#EXP} % 2 )) -ne 0 ] && EXP="0$EXP"
		else
			EXP="010001"
		fi
		printf "DESC=\"%s\" SRC=\"%s\" MOD=%s EXP=%s\n" "$DESC" "$SRC" "$MOD" "$EXP"
	fi
)
####################################################################################
#                                                                                  #
# check image file                                                                 #
#                                                                                  #
####################################################################################
if [ -z "$1" ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
	usage 1>&2
	[ -z "$1" ] && exit 2 || exit 0
else
	image_file="$1"
	shift
	if [ -z "$1" ]; then
		usage 1>&2
		exit 2
	fi
fi
if ! [ -f "$image_file" ]; then
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m does not exist.\033[0m\a\n" "$image_file" 1>&2
	exit 3
fi
####################################################################################
#                                                                                  #
# get the path for needed external commands, if called in any toolchain            #
#                                                                                  #
# looks a little bit complicated, but has to support definitions for BusyBox       #
# applets as commands to be used and simple quoting isn't enough to ensure proper  #
# substitution, but spreading 'eval' statements all over the code looks ugly, too  #
#                                                                                  #
####################################################################################
if [ -n "$YF_SIGNIMAGE_TAR" ]; then
	__YF_SIGNIMAGE_TAR="$YF_SIGNIMAGE_TAR"
	__yf_signimage_tar()
	{
		"$__YF_SIGNIMAGE_TAR" "$@"
	}
	YF_SIGNIMAGE_TAR="__yf_signimage_tar"
else
	YF_SIGNIMAGE_TAR="tar"
fi
if [ -n "$YF_SIGNIMAGE_DD" ]; then
	__YF_SIGNIMAGE_DD="$YF_SIGNIMAGE_DD"
	__yf_signimage_dd()
	{
		"$__YF_SIGNIMAGE_DD" "$@"
	}
	YF_SIGNIMAGE_DD="__yf_signimage_dd"
else
	YF_SIGNIMAGE_DD="dd"
fi
if [ -n "$YF_SIGNIMAGE_OPENSSL" ]; then
	__YF_SIGNIMAGE_OPENSSL="$YF_SIGNIMAGE_OPENSSL"
	__yf_signimage_openssl()
	{
		"$__YF_SIGNIMAGE_OPENSSL" "$@"
	}
	YF_SIGNIMAGE_OPENSSL="__yf_signimage_openssl"
else
	YF_SIGNIMAGE_OPENSSL="openssl"
fi
####################################################################################
#                                                                                  #
# prepare a temporary directory and cleanup on exit                                #
#                                                                                  #
####################################################################################
tmp=$(__mktmp -d)
if [ $? -eq 127 ] || [ ${#tmp} -eq 0 ]; then
	tmp="/tmp/tmp.$(date +%s).$$"
	mkdir -p "$tmp"
fi
#trap "rm -r \"$tmp\"" EXIT HUP INT
####################################################################################
#                                                                                  #
# check OpenSSL presence and version                                               #
#                                                                                  #
####################################################################################
show_version || exit 32
cnf="$("$YF_SIGNIMAGE_OPENSSL" version 2>&1 | sed -n -e "s|WARNING: can't open config file: \(.*\)\$|\1|p")"
if [ -n "$cnf" ]; then # configuration file missing
	touch "$tmp/openssl.cnf"
	export OPENSSL_CONF="$tmp/openssl.cnf"
fi
printf "Check \033[1mdgst\033[0m command ... " 1>&2
if printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst 2>&1 | grep -q '^(stdin)=' 2>/dev/null 1>&2; then
	show_ok
else
	show_error
	exit 33
fi
printf "Check \033[1mrsautl\033[0m command ... " 1>&2
if printf "" | "$YF_SIGNIMAGE_OPENSSL" rsautl 2>&1 | grep -q '^no keyfile specified' 2>/dev/null 1>&2; then
	show_ok
else
	show_error
	exit 34
fi
####################################################################################
#                                                                                  #
# use 'force-local' option with GNU TAR, if the image name contains a colon        #
#                                                                                  #
####################################################################################
if [ -n "$(expr "$image_file" : ".*\(:\).*")" ]; then
	"$YF_SIGNIMAGE_TAR" --help 2>&1 | grep -q 'force-local' 2>/dev/null && force_local="--force-local"
else
	force_local=""
fi
####################################################################################
#                                                                                  #
# If the signature isn't the last file (we've checked the length already), we have #
# to find the offset of the last member with the signature name - the last one is  #
# important, because the archive may contain more than one member with the same    #
# name and the last one will overwrite all previously extracted files.             #
#                                                                                  #
# Here we could try to find the member name in the file content, but this would be #
# impossible with "normal" commands (I don't know any applet, which may find a     #
# string in a binary file and return the offsets of these strings) and searching   #
# a hexdump output is really boring and much too slow.                             #
#                                                                                  #
# A better approach should be to count the archive members from start of file and  #
# to compute their respective offsets - we're interested in the last occurence of  #
# ./var/signature only.                                                            #
# We compute the offset and size of every member here, it makes things easier      #
# while checking signature's presence and format.                                  #
#                                                                                  #
####################################################################################
offset=0
# shellcheck disable=SC2086,SC2162
"$YF_SIGNIMAGE_TAR" -t -v -f "$image_file" $force_local | \
sed -n -e "s|^[^ ]* *[^ ]* *\([0-9]*\) *[^ ]* *[^ ]* *\(.*\)\$|SIZE=\1 MEMBER=\2|p" | \
while read line; do
	eval "$line"
	file_offset=$offset
	file_start=$(( file_offset + 512 ))
	file_end=$(( file_start + SIZE ))
	offset=$(( ( ( file_end + 511 ) / 512 ) * 512 ))
	printf "HEADER=%u START=%u END=%u SIZE=%u BLOCKS=%u MEMBER=\"%s\"\n" "$file_offset" "$file_start" "$file_end" "$SIZE" "$(( ( offset - file_offset ) / 512 ))" "$MEMBER" >>"$tmp/image_members"
done
####################################################################################
#                                                                                  #
# get the signature file from the image and check that it is in the expected       #
# format, before we waste a lot of time with checking an invalid signature file    #
#                                                                                  #
####################################################################################
last_sig=0
i=0
# shellcheck disable=SC2162
while read line; do
	i=$(( i + 1 ))
	eval "$line"
	if [ "$MEMBER" = "$signature_file" ]; then
		last_sig=$i
	fi
done <"$tmp/image_members"
if [ $last_sig -eq 0 ]; then
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m contains no signature file (\033[1;37m%s\033[1;31m).\033[0m\a\n" "$image_file" "$signature_file" 1>&2
	exit 4
fi
eval "$(sed -n -e "${last_sig}p" "$tmp/image_members")"
if [ "$SIZE" -eq 0 ] || [ "$SIZE" -gt 512 ]; then
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m contains an invalid signature file (\033[1;37m%s\033[1;31m).\033[0m\a\n" "$image_file" "$signature_file" 1>&2
	exit 5
fi
# shellcheck disable=SC2086
"$YF_SIGNIMAGE_TAR" -x -f "$image_file" -C "$tmp" $force_local "$signature_file" 2>/dev/null
fs="$(wc -c < "$tmp/var/signature")"
if [ "$fs" -ne 128 ] && [ "$fs" -ne 256 ] && [ "$fs" -ne 512 ]; then
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m contains an invalid signature file (\033[1;37m%s\033[1;31m).\033[0m\a\n" "$image_file" "$signature_file" 1>&2
	exit 5
fi
seek_image=$(( HEADER / 512 ))
####################################################################################
#                                                                                  #
# copy the specified public keys from different sources to our temporary key list  #
#                                                                                  #
####################################################################################
touch "$tmp/public_keys"
while [ "$#" -gt 0 ]; do
	case "$1" in
		"-f")
			if [ -z "$2" ]; then
				printf "\033[1;31mMissing filename after \033[1;37m-f\033[1;31m option.\033[0m\a\n" 1>&2
				exit 2
			fi
			if ! [ -f "$2" ]; then
				printf "\033[1;31mThe specified public key files list \033[1;37m%s\033[1;31m does not exist.\033[0m\a\n" "$2" 1>&2
				exit 6
			fi
			i=0
			# shellcheck disable=SC2162
			while read filename; do
				i=$(( i + 1 ))
				if [ -f "$filename" ]; then
					unset MOD
					unset EXP
					unset SRC
					unset DESC
					MOD=$(sed -n -e "1p" "$filename")
					if [ ${#MOD} -eq 0 ]; then
						printf "\033[1;33mUnable to read MOD value from file \033[1;37m%s\033[1;33m, which was included on line \033[1;37m%u\033[1;33m of file \033[1;37m%s\033[1;33m, file skipped.\033[0m\n" "$filename" "$i" "$2" 1>&2
						continue
					fi
					EXP=$(sed -n -e "2p" "$filename")
					[ ${#EXP} -eq 0 ] && EXP=010001
					DESC="$(printf "line %u of %s\n" "$i" "$2")"
					printf "DESC=\"%s\" SRC=\"%s\" MOD=%s EXP=%s\n" "$DESC" "$filename" "$MOD" "$EXP" >>"$tmp/public_keys"
				else
					printf "\033[1;33mFile \033[1;37m%s\033[1;33m from line \033[1;37m%u\033[1;33m of \033[1;37m%s\033[1;33m does not exist, line skipped.\033[0m\n" "$filename" "$i" "$2" 1>&2
				fi
			done <"$2"
			shift 2
			;;
		"-b")
			builtin_keys >>"$tmp/public_keys"
			rc=$?
			if [ $rc -ne 0 ]; then
				printf "\033[1;31mThe option \033[1m-b\033[0m may only be used on a FRITZ!OS device.\033[0m\n" 1>&2
				exit $rc
			fi
			shift
			;;
		"-c")
			if [ -z "$2" ]; then
				printf "\033[1;31mMissing filename after \033[1;37m-c\033[1;31m option.\033[0m\a\n" 1>&2
				exit 2
			fi
			if ! [ -f "$2" ]; then
				printf "\033[1;31mThe specified public key file \033[1;37m%s\033[1;31m (raw format) does not exist.\033[0m\a\n" "$2" 1>&2
				exit 6
			fi
			i=0
			# shellcheck disable=SC2162
			while read line; do
				i=$(( i + 1 ))
				unset MOD
				unset EXP
				unset SRC
				unset DESC
				eval "$line"
				if [ -z "$MOD" ]; then
					printf "\033[1;31mMissing \033[1;37mMOD\033[1;31m value on line %u of raw file \033[1;37m%s\033[1;31m.\033[0m\a\n" "$i" "$2" 1>&2
					exit 12
				elif [ -z "$EXP" ]; then
					EXP="010001"
				fi
				if [ -z "$DESC" ]; then
					# shellcheck disable=SC2031
					[ -n "$SRC" ] && DESC="$(printf "line %u of %2\n" "$i" "$2")" || DESC="$(printf "line %u\n" "$i")"
				fi
				# shellcheck disable=SC2031
				[ -n "$SRC" ] && SRC="$(printf "%s\n" "$2")"
				printf "DESC=\"%s\" SRC=\"%s\" MOD=%s EXP=%s\n" "$DESC" "$SRC" "$MOD" "$EXP" >>"$tmp/public_keys"
			done <"$2"
			shift 2
			;;
		"-a")
			if [ -z "$2" ]; then
				printf "\033[1;31mMissing filename after \033[1;37m-a\033[1;31m option.\033[0m\a\n" 1>&2
				exit 2
			fi
			if ! [ -f "$2" ]; then
				printf "\033[1;31mThe specified public key file \033[1;37m%s\033[1;31m (AVM format) does not exist.\033[0m\a\n" "$2" 1>&2
				exit 6
			fi
			unset MOD
			unset EXP
			MOD="$(sed -n -e "1p" "$2")"
			EXP="$(sed -n -e "2p" "$2")"
			if [ ${#MOD} -gt 0 ]; then
				[ ${#EXP} -eq 0 ] && exp=010001
				printf "DESC=\"AVM formatted file from command line\" SRC=\"%s\" MOD=%s EXP=%s\n" "$2" "$MOD" "$EXP" >>"$tmp/public_keys"
			else
				printf "\033[1;33mUnable to read MOD value from file \033[1;37m%s\033[1;33m, file skipped.\033[0m\n" "$filename" "$2" 1>&2
			fi
			shift 2
			;;
		"-p"|"-d")
			if [ -z "$2" ]; then
				printf "\033[1;31mMissing filename after \033[1;37m%s\033[1;31m option.\033[0m\a\n" "$1" 1>&2
				exit 2
			fi
			[ "$1" = "-p" ] && format="PEM" || format="DER"
			if ! [ -f "$2" ]; then
				printf "\033[1;31mThe specified public key file \033[1;37m%s\033[1;31m (%s format) does not exist.\033[0m\a\n" "$2" "$format" 1>&2
				exit 6
			fi
			read_openssl_file "$2" "$format" >>"$tmp/public_keys" || exit 12
			shift 2
			;;
		"-s")
			if [ -n "$2" ]; then
				printf "\033[1;31mExtra data specified after \033[1;37m%s\033[1;31m option.\033[0m\a\n" "$1" 1>&2
				exit 2
			fi
			if ! is_fritzos_environment; then
				printf "\033[1;31mThe option \033[1;37m-s\033[1;31m may only be used on a FRITZ!OS device.\033[0m\a\n" 1>&2
				exit 2
			fi
			if [ -s "$tmp/public_keys" ]; then
				printf "\033[1;31mThe option \033[1;37m-s\033[1;31m may only be used without any other keys.\033[0m\a\n" 1>&2
				exit 2
			fi
			if ! read_box_key >>"$tmp/public_keys"; then
				printf "\033[1;31mUnable to read RSA key from FRITZ!OS device.\033[0m\n" 1>&2
				exit $rc
			fi
			shift
			;;
		*)
			printf "\033[1;31mUnknown option \033[1;37m%s\033[1;31m specified on command line.\033[0m\a\n" "$1" 1>&2
			exit 1
			;;
	esac
done
if ! [ -s "$tmp/public_keys" ]; then
	printf "\033[1;31mNone of the specified public keys could be loaded.\033[0m\a\n" 1>&2
	exit 11
fi
####################################################################################
#                                                                                  #
# determine the used private key ... try to decode the signature file with every   #
# public key specified, until the usable was found or the end of list is reached   #
#                                                                                  #
####################################################################################
[ "$(sed -n -e "\$=" "$tmp/public_keys")" -gt 1 ] && printf "Trying to determine the correct key now ...\n" 1>&2
key_found=0
valid_algo=0
# shellcheck disable=SC2162
while read line; do
	eval "$line"
	printf "Checking the public key from \033[1m%s\033[0m ... " "$SRC" 1>&2
	modulus_to_der "$MOD" "$EXP" >"$tmp/pubkey.der"
	output="$("$YF_SIGNIMAGE_OPENSSL" rsautl -verify -pubin -inkey "$tmp/pubkey.der" -keyform der -asn1parse -in "$tmp/var/signature" 2>&1)"
	rc=$?
	if [ $rc -eq 0 ]; then
		key_found=1
		show_ok
		algo=$(printf "%s\n" "$output" | sed -n -e "s|^.*OBJECT.*:\(.*\)\$|\1|p" 2>/dev/null)
		if [ ${#algo} -gt 0 ]; then
			printf "Checking support for the used hash algorithm \033[1m%s\033[0m ... " "$algo" 1>&2
			if printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst -"$algo" 2>&1 2>/dev/null 1>&2; then
				show_ok
			else
				show_error
				exit 10
			fi
		else
			show_error
			exit 8
		fi
	else
		show_error
	fi
done <"$tmp/public_keys"
if [ $key_found -eq 0 ]; then
	printf "\033[1;31mNo usable public key was found.\033[0m\n" 1>&2
	exit 7
fi
####################################################################################
#                                                                                  #
# now we check the signature with the openssl binary, we prepare the changed image #
# file in a subshell and pipe its output to openssl                                #
#                                                                                  #
####################################################################################
res="$( ( "$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=$seek_image status=none 2>/dev/null;
"$YF_SIGNIMAGE_DD" if=/dev/zero bs=512 count=2 status=none 2>/dev/null;
"$YF_SIGNIMAGE_DD" if="$image_file" bs=512 skip=$(( seek_image + 2 )) status=none 2>/dev/null ) | \
"$YF_SIGNIMAGE_OPENSSL" dgst -"$algo" -verify "$tmp/pubkey.der" -keyform der -signature "$tmp/var/signature")"
rc=$?
if [ $rc -ne 0 ]; then
	printf "\033[1;31mSignature verification failed.\033[0m\n" 1>&2
	exit 64
fi
####################################################################################
#                                                                                  #
# all done                                                                         #
#                                                                                  #
####################################################################################
printf "\033[1;32mVerification succeeded.\033[0m\n" 1>&2
exit 0
####################################################################################
#                                                                                  #
# end of file                                                                      #
#                                                                                  #
####################################################################################
