#! /bin/sh
# vim: set tabstop=4 syntax=sh :
# SPDX-License-Identifier: GPL-2.0-or-later WITH exceptions
#######################################################################################################
#                                                                                                     #
# sign a TAR archive with a RSA key, like AVM's firmware is signed                                    #
#                                                                                                     #
###################################################################################################VER#
#                                                                                                     #
# yf_sign_image, version 1.0.1                                                                        #
#                                                                                                     #
# Some functions in this script were taken from the YourFritz Shell Script library (YF_SCRIPTLIB)     #
# and/or from YourFritz UI framework (YF_UI), which is a part of the YourFritz project from           #
# https://github.com/PeterPawn/YourFritz.                                                             #
#                                                                                                     #
###################################################################################################CPY#
#                                                                                                     #
# Copyright (C) 2016-2021 P. Haemmerlein (peterpawn@yourfritz.de)                                     #
#                                                                                                     #
###################################################################################################LIC#
#                                                                                                     #
# This script is licensed according to the following terms:                                           #
#                                                                                                     #
# This project is free software, you can redistribute it and/or modify it under the terms of the GNU  #
# General Public License as published by the Free Software Foundation; either version 2 of the        #
# License, or (at your option) any later version.                                                     #
#                                                                                                     #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without   #
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      #
# General Public License under http://www.gnu.org/licenses/gpl-2.0.html for more details.             #
#                                                                                                     #
# If you're including YF_UI functions in your own script(s) permanently, to deliver only one single   #
# file, you HAVE TO KEEP these functions together as one single continous part in your script AND     #
# this section HAS TO BE prefixed by its own header, like it's created by framework generator AND the #
# end of this section HAS TO BE marked clearly.                                                       #
#                                                                                                     #
# If you've changed anything to the content of UI functions, these changes HAVE TO BE marked with the #
# name of author AND the date of change AND a short explanation, what was changed (if it's not        #
# obvious).                                                                                           #
#                                                                                                     #
# In each case the copyright notice and licensing terms have to be kept as provided, but you may add  #
# your own copyright notice(s) and your own license conditions, as long as they're conforming to the  #
# rights granted by GPLv2 or later (with the exception above) and do not restrict or expand rights to #
# these parts of code, which are licensed under YourFritz conditions above.                           #
#                                                                                                     #
#################################################################################################EMBED#
#                                                                                                     #
# determine our script path to locate the include file                                                #
#                                                                                                     #
#######################################################################################################
my_path="$0"
[ "${my_path%/*}" = "$my_path" ] && my_path="." || my_path="${my_path%/*}"
# shellcheck disable=SC2034
my_name="${0##*/}"
box_key_name="/var/flash/websrv_ssl_key"
signature_file="./var/signature"
#######################################################################################################
#                                                                                                     #
# include the common file definitions                                                                 #
#                                                                                                     #
#######################################################################################################
include_file="${YF_SIGNIMAGE_INCLUDE:-$my_path/image_signing_files.inc}"
if ! [ -r "$include_file" ]; then
	printf "\033[1;31mInclude file \033[1;37m%s\033[1;31m isn't readable.\033[0m\a\n" "$include_file" 1>&2
	exit 127
fi
# shellcheck source=./image_signing_files.inc
. "$include_file"
filename_prefix="$YF_SIGNIMAGE_FILES"
#######################################################################################################
#                                                                                                     #
# get the names of needed external commands, if called from any cross-development toolchain           #
#                                                                                                     #
#######################################################################################################
if [ -n "$YF_SIGNIMAGE_TAR" ]; then
	__YF_SIGNIMAGE_TAR="$YF_SIGNIMAGE_TAR"
	__yf_signimage_tar()
	{
		"$__YF_SIGNIMAGE_TAR" "$@"
	}
	YF_SIGNIMAGE_TAR="__yf_signimage_tar"
else
	YF_SIGNIMAGE_TAR="tar"
fi
if [ -n "$YF_SIGNIMAGE_DD" ]; then
	__YF_SIGNIMAGE_DD="$YF_SIGNIMAGE_DD"
	__yf_signimage_dd()
	{
		"$__YF_SIGNIMAGE_DD" "$@"
	}
	YF_SIGNIMAGE_DD="__yf_signimage_dd"
else
	YF_SIGNIMAGE_DD="dd"
fi
if [ -n "$YF_SIGNIMAGE_OPENSSL" ]; then
	__YF_SIGNIMAGE_OPENSSL="$YF_SIGNIMAGE_OPENSSL"
	__yf_signimage_openssl()
	{
		"$__YF_SIGNIMAGE_OPENSSL" "$@"
	}
	YF_SIGNIMAGE_OPENSSL="__yf_signimage_openssl"
else
	YF_SIGNIMAGE_OPENSSL="openssl"
fi
#######################################################################################################
#                                                                                                     #
# some subfunctions                                                                                   #
#                                                                                                     #
#######################################################################################################
show_error() ( printf "\033[1;31mFAILED\033[0m\a\n" 1>&2; )
show_ok() ( printf "\033[1;32mOK\033[0m\n" 1>&2; )
show_version()
(
	v=$("$YF_SIGNIMAGE_OPENSSL" version 2>/dev/null)
	if [ $? -eq 127 ]; then
		printf "\033[1;31mMissing \033[1;37mopenssl\033[1;31m binary, set \033[1;37mYF_SIGNIMAGE_OPENSSL\033[1;31m variable to its path name.\033[0m\a\n" 1>&2
		exit 1
	else
		printf "Found \033[1;34m%s\033[0m\n" "$v" 1>&2
		exit 0
	fi
)
__check_required_command()
(
	IFS=:
	set -- "$1"
	for n in "$@"; do
		command -v "$n" 2>/dev/null 1>&2 && exit 0
	done
	exit 1
)
__random()
(
	[ -f /proc/sys/kernel/random/uuid ] && cat /proc/sys/kernel/random/uuid && exit 0
	for h in md5sum sha1sum; do
		if __check_required_command $h; then
			if [ -c /dev/urandom ] && __check_required_command "dd"; then
				$YF_SIGNIMAGE_DD if=/dev/urandom bs=32 count=1 status=none 2>/dev/null | $h | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
			fi
			for f in /proc/self/stat /proc/self/status /proc/interrupts /proc/softirqs /proc/uptime; do
				if [ -f $f ]; then
					$h < $f | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
				fi
			done
		fi
	done
	__check_required_command "date" && date +%s && exit 0
	printf "%d" "$$"
)
__mktmp()
(
	if __check_required_command "mktemp"; then
		n="$(mktemp "$@" 2>/dev/null)"
	fi
	if [ -z "$n" ]; then
		t="${TMPDIR:-/tmp}"
		[ "$1" = "-d" ] && d=1 || d=0
		[ "$1" = "-p" ] && t="$2"
		[ -z "$t" ] && t="/tmp"
		n="$t/$(__random)"
		if [ $d -eq 1 ]; then
			[ -d "$n" ] && n="$t/$(__random)"
			mkdir -p "$n" 2>/dev/null
		else
			while [ -e "$n" ]; do
				n="$t/$(__random)"
			done
			touch "$n" 2>/dev/null
		fi
	fi
	printf "%s\n" "$n"
)
__read_password()
(
	# parameter strings may contain ANSI sequences to format terminal output
	# shellcheck disable=SC2059
	printf "$@" 1>&2
	tty_settings="$(stty -g)"
	stty -echo
	# shellcheck disable=SC2162
	read password
	stty "$tty_settings" 2>/dev/null 1>&2
	printf "\n" 1>&2
	printf "%s\n" "$password"
)
__yf_get_script_lines()
{
	sed -n -e "/^#*${1}#\$/,/^#\{20\}.*#\$/p" -- "$0" | \
	sed -e '1d;$d' | \
	sed -e 's|# \(.*\) *#$|\1|' | \
	sed -e 's|^#*#$|--|p' | \
	sed -e '$d' | \
	sed -e 's| *$||'
}
__yf_show_script_name()
{
	[ -n "$1" ] && printf -- '%s' "$1"
	printf -- '%s' "${0#*/}"
	[ -n "$1" ] && printf -- "\033[0m"
}
__yf_show_license()
{
	__yf_get_script_lines 'LIC'
}
__yf_show_version()
{
	printf "\n\033[1m%s\033[0m, %s\n" "$(__yf_get_script_lines 'VER' | sed -n -e "2s|^\([^,]*\),.*|\1|p")" "$(__yf_get_script_lines 'VER' | sed -n -e "2s|^[^,]*, \(.*\)|\1|p")"
}
__yf_show_copyright()
{
	__yf_get_script_lines 'CPY'
}
#######################################################################################################
#                                                                                                     #
# usage screen, caller has to redirect output to STDERR if needed                                     #
#                                                                                                     #
#######################################################################################################
usage()
(
	__yf_show_version
	__yf_show_copyright
	__yf_show_license
	printf "\nPurpose:\n\n\033[1;34mSign a TAR archive file as firmware image for FRITZ!OS devices.\033[0m\n\n"
	printf "Usage:\n\n"
	printf "\033[1;32m%s \033[0m" "$0"
	printf "\033[1mimagefile\033[0m [\033[1mpassword\033[0m]\n\n"
	printf "\033[1mimagefile\033[0m is the archive to sign, it has to follow some rules according its format (see below).\n\n"
	printf "The \033[1mpassword\033[0m is the one of your private key, which will be used to encrypt your signature. This\n"
	printf "password (if your private key was stored with encryption) will be read from terminal (without\n"
	printf "echoing typed characters), if it's not specified as parameter while calling the script or was\n"
	printf "preset using an environment value called \033[1mYF_SIGNIMAGE_KEYPASSWORD\033[0m.\n\n"
	printf "The signed image will be written to STDOUT, you're in charge to redirect it to the proper target\n"
	printf "location. If STDOUT is connected to a terminal device, the script will be aborted.\n\n"
	printf "The default hash algorithm used is MD5, as it's used by AVM's current implementation. If you know\n"
	printf "(for sure), that you will only use non-AVM scripts/components to sign and verify, you may specify\n"
	printf "a better hash algorithm (remember that \033[1mopenssl\033[0m binary still has to support it) with a variable\n"
	printf "\033[1mYF_SIGNIMAGE_HASH\033[0m in the environment, which contains the name of algorithm to use.\n"
	printf "It has to be one of:\n\n"
	for algo in $supported_hashes; do
		printf -- "- %s\n" "$algo"
	done
	printf "\n"
	printf "A special use case is signing of a TAR file directly in a FRITZ!OS environment, if such a signed\n"
	printf "file is surely verified later only on the same device. Then the RSA key from \033[1mwebsrv_ssl_key.pem\033[0m\n"
	printf "may be used instead of an additional key and there's no need to specify a password for the key,\n"
	printf "because it's available with \033[1mprivatekeypassword\033[0m from device (hardware) settings.\n\n"
	printf "To switch this script into 'internal-only mode', set the environment variable \033[1mYF_SIGNIMAGE_ON_BOX\033[0m\n"
	printf "to a value of '1' while calling. But be aware, that a key size other than 1024 bits would lead to\n"
	printf "impossibility to verify the signature with AVM's components ... and newer FRITZ!OS versions use a\n"
	printf "2048-bit RSA key to protect their TLS connections.\n\n"
	printf "If you're trying to sign using this mode on a FRITZ!OS device, where HWRevision values from the\n"
	printf "urlader and shell environment are different (due to an 'alien' firmware running, while the value\n"
	printf "from bootloader isn't changeable), the script will cease to detect the host system as a FRITZ!OS\n"
	printf "device. In this case you may provide any non-empty value with a variable named\n"
	printf "YF_SIGNIMAGE_IGNORE_HWREVISION - thus the result of this check will be ignored.\n\n"
	printf "The input image has to use the traditional TAR format without any extensions. If you'll use the\n"
	printf "GNU tar implementation (https://www.gnu.org/software/tar), you have to specify the \033[1m--format=gnu\033[0m\n"
	printf "or \033[1m--format=oldgnu\033[0m option while creating the file.\n\n"
	printf "Furthermore the first archived member has to be a directory entry with name \033[1m./var/\033[0m - the starting\n"
	printf "dot is important and this script will deny to sign an image, which isn't starting with exactly\n"
	printf "such an entry. AVM's components will filter out any names not starting with this path name and\n"
	printf "the main purpose of this script is still to sign images in a compatible manner to AVM's FRITZ!OS.\n\n"
	printf "If the provided input image already contains a member called \033[1m./var/signature\033[0m, it has to be the\n"
	printf "very last entry and will be replaced by a new signature. If it's not the last entry, the script\n"
	printf "will abort the signing process. If no signature file was found on input archive, a new one is\n"
	printf "appended after the signed payload.\n\n"
	printf "To make integration of this script into a foreign toolchain easier, the location of some needed\n"
	printf "tools may be overwritten with environment values. Currently there are three utilities needed:\n"
	printf "\033[1mtar\033[0m, \033[1mopenssl\033[0m and \033[1mdd\033[0m (the latter one is found in POSIX specifications).\n"
	printf "Their locations may be specified with variables \033[1mYF_SIGNIMAGE_<toolname>\033[0m, where \033[1m<toolname>\033[0m\n"
	printf "is the name of the utility in uppercase letters. If a value isn't present, the simple name\n"
	printf "of this tool will be used to call it. You may use spaces within these values, if you ensure\n"
	printf "proper quotes while calling (e.g. YF_SIGNIMAGE_TAR='busybox tar' to use the applet of your\n"
	printf "BusyBox binary).\n\n"
	printf "The location of crypto materials to be used (private and public keys, RNG seed, etc.), will be\n"
	printf "read from an include file with the name \033[1mimage_signing_files.inc\033[0m. The file has to be stored in\n"
	printf "the same directory as this script. Please read the comments in this file, if you want to change\n"
	printf "the places, where other files will be searched. To change the location, where the include file\n"
	printf "will be expected, you may use an environment value \033[1mYF_SIGNIMAGE_INCLUDE\033[0m with the (relative or\n"
	printf "absolute) path name of it.\n\n"
	printf "To keep backward compatibility with previous versions, the provided include file still takes the\n"
	printf "environment variable \033[1mname_prefix\033[0m into account - but this name shouldn't be used any longer. Use\n"
	printf "\033[1mYF_SIGNIMAGE_FILES\033[0m variable instead - it's presence is checked first and any settings here, will\n"
	printf "overrule all others. If there's no variable with any of these names, due to historic reasons the\n"
	printf "presence of \033[1mFREETZ_IMAGE_SIGNING_PREFIX\033[0m will be checked. An existing variable with this name will\n"
	printf "be used next - otherwise a value of \033[1m\$HOME/image_signing\033[0m gets assigned in the last resort.\n\n"
	printf "The file extensions from include file shouldn't be changed without strong knowledge regarding\n"
	printf "usage of cryptographic tools. Please don't blame the author, if your own changes to these values\n"
	printf "render the script(s) useless (beside you've to respect the license terms even, which are denying\n"
	printf "responsibility of the author). The extension names were only moved to the include file to prevent\n"
	printf "most rationales for own changes to the script files.\n\n"
)
#######################################################################################################
#                                                                                                     #
# compute checksum of a TAR header                                                                    #
#                                                                                                     #
#######################################################################################################
checksum()
(
	read_values()
	{
		# shellcheck disable=SC2162,SC2034
		while read pos left right; do
			sum=$(( sum + 0$left ))
		done
		printf "%d" "$sum"
	}
	sum=0
	cmp -l -- "$1" /dev/zero 2>/dev/null | read_values
)
#######################################################################################################
#                                                                                                     #
# try to identify FRITZ!OS as runtime environment (not too sophisticated, but it                      #
# should be able to make this distinction)                                                            #
#                                                                                                     #
#######################################################################################################
is_fritzos_environment()
(
	eva_prompt="Eva_AVM"
	# shellcheck disable=SC2154
	[ ${#HWRevision} -eq 0 ] && exit 1
	[ ${#CONFIG_ENVIRONMENT_PATH} -eq 0 ] && exit 1
	[ -d "$CONFIG_ENVIRONMENT_PATH" ] || exit 1
	[ -f "$CONFIG_ENVIRONMENT_PATH/environment" ] || exit 1
	HWRev="$(sed -n -e "s|^HWRevision\t\(.*\)\$|\1|p" "$CONFIG_ENVIRONMENT_PATH/environment")"
	[ ${#HWRev} -eq 0 ] && exit 1
	if [ "$HWRev" != "$HWRevision" ]; then
		if [ -z "$YF_SIGNIMAGE_IGNORE_HWREVISION" ]; then
			printf "\033[1;31mMismatch of \033[1;37mHWRevision\033[1;31m between shell and urlader environment (\033[1;37m%s\033[1;31m vs. \033[1;37m%s\033[1;31m).\033[0m\a\n" "$HWRev" "$HWRevision" 1>&2
			exit 1
		fi
		printf "\033[1;37mHWRevision\033[1;33m mismatch between shell and urlader environment (\033[1;37m%s\033[1;33m vs. \033[1;37m%s\033[1;33m) ignored.\033[0m\n" "$HWRev" "$HWRevision" 1>&2
	fi
	prompt="$(sed -n -e "s|^prompt\t\(.*\)\$|\1|p" "$CONFIG_ENVIRONMENT_PATH/environment")"
	[ ${#prompt} -eq 0 ] && exit 1
	[ "$prompt" != "$eva_prompt" ] && exit 1
	exit 0
)
#######################################################################################################
#                                                                                                     #
# check parameters                                                                                    #
#                                                                                                     #
#######################################################################################################
if [ -z "$1" ]; then
	usage 1>&2
	exit 1
elif [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
	usage
	exit 0
else
	image_file="$1"
fi
if ! [ -f "$image_file" ]; then
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m does not exist.\033[0m\a\n" "$image_file" 1>&2
	exit 1
fi
if [ -t 1 ]; then
	printf "\033[1;31mThe output stream is a terminal device, please redirect output to a file.\033[0m\a\n" 1>&2
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# some output due to license terms                                                                    #
#                                                                                                     #
#######################################################################################################
__yf_show_version 1>&2
__yf_show_copyright 1>&2
printf "\nLicensed to you according to GPLv2 or a later version, with some additions.\nPlease refer to the usage screen for detailed license terms.\n\n" 1>&2
#######################################################################################################
#                                                                                                     #
# check OpenSSL presence and version                                                                  #
#                                                                                                     #
#######################################################################################################
show_version || exit 1
printf "Check \033[1mdgst\033[0m command ... " 1>&2
printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst 2>&1 | grep -q '^(stdin)=' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok
else
	show_error
	exit 1
fi
printf "Check \033[1mrsa\033[0m command ... " 1>&2
printf "" | "$YF_SIGNIMAGE_OPENSSL" rsa 2>&1 | grep -q '^unable to load' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok
else
	show_error
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# check the specified hash algorithm and verify, it's provided by the openssl binary                  #
#                                                                                                     #
#######################################################################################################
if [ "${#YF_SIGNIMAGE_HASH}" -gt 0 ]; then
	check_algo="$(printf "%s\n" "$YF_SIGNIMAGE_HASH" | sed -e "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/")"
	hash_algo=""
	for algo in md5 sha1 sha224 sha256 sha384 sha512 whirlpool; do
		if [ "$algo" = "$check_algo" ]; then
			hash_algo=$algo
			break
		fi
	done
	if [ "${#hash_algo}" -eq 0 ]; then
		printf "\033[1;31mUnknown or unsupported (by this script) hash algorithm \033[1;37m%s\033[1;31m specified.\033[0m\a\n" "$YF_SIGNIMAGE_HASH" 1>&2
		exit 1
	fi
else
	hash_algo="md5"
fi
printf "Verify hash algorithm \033[1m%s\033[0m is supported ... " "$hash_algo" 1>&2
printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst -$hash_algo 2>&1 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok
else
	show_error
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# use 'force-local' option with GNU TAR, if the image name contains a colon                           #
#                                                                                                     #
#######################################################################################################
unset force_local
[ -n "$(expr "$image_file" : ".*\(:\).*")" ] && \
"$YF_SIGNIMAGE_TAR" --help 2>&1 | grep -q 'force-local' 2>/dev/null && \
force_local="--force-local"
#######################################################################################################
#                                                                                                     #
# check the special case of signing on the FRITZ!Box with the internal key                            #
#                                                                                                     #
#######################################################################################################
on_box=0
if [ ${#YF_SIGNIMAGE_ON_BOX} -gt 0 ]; then
	if [ "$YF_SIGNIMAGE_ON_BOX" = "1" ]; then
		if ! is_fritzos_environment; then
			printf "\033[1;31mThe special mode - to sign an image with the RSA key from a device - may only be used in a FRITZ!OS environment.\033[0m\n" 1>&2
			exit 1
		else
			if ! __check_required_command "privatekeypassword"; then
				printf "\033[1;31mThe \033[1;37mprivatekeypassword\033[1;31m executable is missing.\033[0m\a\n" 1>&2
				exit 1
			else
				KEYPASSWORD="$(privatekeypassword 2>/dev/null)"
				if [ ${#KEYPASSWORD} -eq 0 ]; then
					printf "\033[1;31mError determining the password of RSA key from FRITZ!OS.\033[0m\a\n" 1>&2
					exit 1
				else
					filename_prefix="$box_key_name"
					private_extension="pem"
					on_box=1
				fi
			fi
		fi
	fi
fi
#######################################################################################################
#                                                                                                     #
# verify input file format                                                                            #
#                                                                                                     #
#######################################################################################################
printf "Checking input file format ... " 1>&2
if ! "$YF_SIGNIMAGE_DD" if="$image_file" bs=1 skip=257 count=5 status=none 2>/dev/null | grep -q "^ustar\$" 2>/dev/null; then
	show_error
	printf "\033[1;31mInput file doesn't look like a TAR archive.\033[0m\a\n" 1>&2
	exit 1
fi
if "$YF_SIGNIMAGE_DD" if="$image_file" bs=100 count=1 status=none 2>/dev/null | grep -q "PaxHeaders" 2>/dev/null; then
	show_error
	printf "\033[1;31mInput file contains extended headers (PaxHeaders) and may not be signed this way.\033[0m\a\n" 1>&2
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# check first archive member (name=./var/, type=directory)                                            #
#                                                                                                     #
#######################################################################################################
if ! [ "$("$YF_SIGNIMAGE_DD" if="$image_file" bs=1 count=7 2>/dev/null | base64)" = "Li92YXIvAA==" ] || \
   ! [ "$("$YF_SIGNIMAGE_DD" if="$image_file" bs=1 count=1 skip=156 2>/dev/null)" = "5" ]; then
	show_error
	printf "\033[1;31mFirst member of archive file has to be a directory and has to use the name '\033[1;37m./var/\033[1;31m'.\033[0m\a\n" 1>&2
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# prepare a temporary directory and cleanup on exit                                                   #
#                                                                                                     #
#######################################################################################################
tmp=$(__mktmp -d)
[ $? -eq 127 ] && tmp="/tmp/tmp.$(date +%s).$$" && mkdir -p "$tmp"
trap 'rm -r \"$tmp\" 2>/dev/null 1>&2' EXIT HUP
#######################################################################################################
#                                                                                                     #
# check end of archive headers, GNU tar writes more than needed                                       #
#                                                                                                     #
#######################################################################################################
offset=0
# shellcheck disable=SC2162
"$YF_SIGNIMAGE_TAR" -t -v -f "$image_file" $force_local | \
sed -n -e "s|^[^ ]* *[^ ]* *\([0-9]*\) *[^ ]* *[^ ]* *\(.*\)\$|SIZE=\1 MEMBER=\"\2\"|p" | \
while read line; do
	eval "$line"
	file_offset="$offset"
	file_start="$(( file_offset + 512 ))"
	file_end="$(( file_start + SIZE ))"
	offset="$(( ( ( file_end + 511 ) / 512 ) * 512 ))"
	printf "HEADER=%u START=%u END=%u SIZE=%u BLOCKS=%u MEMBER=\"%s\"\n" "$file_offset" "$file_start" "$file_end" "$SIZE" "$(( ( offset - file_offset ) / 512 ))" "$MEMBER" >>"$tmp/image_members"
done
copy_blocks=0
signature_blocks=0
members="$(wc -l <"$tmp/image_members")"
i=0
# shellcheck disable=SC2162
while read line; do
	i=$(( i + 1 ))
	eval "$line"
	if [ "$MEMBER" = "$signature_file" ]; then
		if [ "$i" -ne "$members" ]; then
			show_error
			printf "\033[1;31mThe input file contains a member '\033[1;37m%s\033[1;31m' already (in the wrong position) and will not be signed by this script.\033[0m\a\n" "$signature_file" 1>&2
			exit 1
		else
			signature_blocks="$(( BLOCKS ))"
		fi
	else
		copy_blocks="$(( copy_blocks + BLOCKS ))"
	fi
done <"$tmp/image_members"
file_size="$(wc -c < "$image_file")"
file_blocks=$(( file_size / 512 ))
eoa_blocks=$(( file_blocks - copy_blocks - signature_blocks ))
show_ok
if [ $signature_blocks -gt 0 ]; then
	printf "\033[1;33mThere's already a signature file in the provided image, it will be replaced by a new one.\033[0m\n" 1>&2
fi
if [ $eoa_blocks -gt 2 ]; then
	printf "\033[1;33mToo much end of archive markers read from input file:\033[0m blocks expected=\033[1m%u\033[0m, blocks present=\033[1m%u\033[0m.\n\033[1;33mInput data will be truncated after last archive member.\033[0m\n" "2" "$eoa_blocks" 1>&2
fi
#######################################################################################################
#                                                                                                     #
# get the password for the private key, if needed                                                     #
#                                                                                                     #
#######################################################################################################
if [ $on_box -eq 0 ]; then
	if grep -q "^Proc-Type:.*ENCRYPTED\$" "${filename_prefix}.${private_extension}" 2>/dev/null; then
		if [ -z "$2" ]; then
			if ! [ -t 0 ]; then
				usage 1>&2
				exit 1
			else
				if [ "${#YF_SIGNIMAGE_KEYPASSWORD}" -eq 0 ]; then
					KEYPASSWORD="$(__read_password "\033[1;34mEnter your password for the signing key: \033[0m")"
				else
					KEYPASSWORD="$YF_SIGNIMAGE_KEYPASSWORD"
				fi
			fi
		else
			KEYPASSWORD="$2"
		fi
	fi
fi
#######################################################################################################
#                                                                                                     #
# check key password first (and key file presence)                                                    #
#                                                                                                     #
#######################################################################################################
if [ $on_box -eq 0 ]; then
	if [ ${#KEYPASSWORD} -gt 0 ]; then
		printf "Checking password for the private key file ... " 1>&2
		printf "%s\n" "$KEYPASSWORD" | "$YF_SIGNIMAGE_OPENSSL" rsa -in "${filename_prefix}.${private_extension}" -noout -passin "stdin" 2>/dev/null 1>&2
		rc=$?
		if [ $rc -eq 0 ]; then
			show_ok
		else
			show_error
			exit 1
		fi
	elif grep -q "^Proc-Type:.*ENCRYPTED\$" "${filename_prefix}.${private_extension}" 2>/dev/null; then
		printf "\033[1;31mThe private key file \033[1;37m%s.%s\033[1;31m seems to be encrypted, you have to specify the password and not an empty string.\033[0m\a\n" "$filename_prefix" "$private_extension" 1>&2
		exit 1
	fi
fi
#######################################################################################################
#                                                                                                     #
# prepare a temporary block as filler, if circumvention of AVM's hash error is needed                 #
#                                                                                                     #
#######################################################################################################
rm -f "$tmp/filler.bin"
touch "$tmp/filler.bin"
if [ -z "$YF_SIGNIMAGE_SKIP_WORKAROUNDS" ]; then
	if [ $(( ( copy_blocks + 2 ) % 20 )) -eq 0 ]; then
		printf "\033[1;33mRepeating first entry once as filler ... \033[0m" 1>&2
		"$YF_SIGNIMAGE_DD" if="$image_file" of="$tmp/filler.bin" bs=512 count=1 status=none 2>/dev/null
		show_ok
	elif [ $(( ( copy_blocks + 3 ) % 20 )) -eq 0 ]; then
		printf "\033[1;33mRepeating first entry two times as filler ...\033[0m" 1>&2
		( "$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=1 status=none 2>/dev/null;
		"$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=1 status=none 2>/dev/null ) >"$tmp/filler.bin"
		show_ok
	fi
fi
#######################################################################################################
#                                                                                                     #
# prepare a temporary block for an empty TAR member - 512 byte header and 512 byte content, it will   #
# be used as "end of archive" header too (2 continous empty blocks with a size of 512 octets)         #
#                                                                                                     #
#######################################################################################################
"$YF_SIGNIMAGE_DD" if=/dev/zero of="$tmp/1K.bin" bs=512 count=2 status=none 2>/dev/null
#######################################################################################################
#                                                                                                     #
# generate the signature file                                                                         #
#                                                                                                     #
# - the input file will be combined with another 1 KB containing zeros                                #
# - any superfluous blocks at the end of the archive are truncated                                    #
# - the original EoA entry will be replaced with an empty 1K block for the sig                        #
# - an additional 1K block of zeros serves as new EoA header                                          #
#                                                                                                     #
#######################################################################################################
printf "Signing the image hash (\033[1m$hash_algo\033[0m) with RSA key from \033[1m%s.%s\033[0m ... " "$filename_prefix" "$private_extension" 1>&2
if "$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=$copy_blocks status=none 2>&1 | cat - "$tmp/filler.bin" "$tmp/1K.bin" "$tmp/1K.bin" | \
"$YF_SIGNIMAGE_OPENSSL" dgst -$hash_algo -sign "${filename_prefix}.${private_extension}" -out "$tmp/signature" -passin "pass:$KEYPASSWORD"; then
	show_ok
	sigsize="$(wc -c < "$tmp/signature")"
else
	show_error
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# stream the shortened image file (without EoA) to STDOUT                                             #
#                                                                                                     #
#######################################################################################################
printf "Copying resulting image to output ... " 1>&2
"$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=$copy_blocks status=none
cat "$tmp/filler.bin"
#######################################################################################################
#                                                                                                     #
# build our own signature member using the first member entry from image                              #
#                                                                                                     #
#######################################################################################################
"$YF_SIGNIMAGE_DD" if="$image_file" of="$tmp/header" bs=512 count=1 status=none 2>/dev/null
printf "%s" "${signature_file##*/}" | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=6 conv=notrunc status=none 2>/dev/null
printf "%04o\000" "$sigsize" | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=131 conv=notrunc status=none 2>/dev/null
printf "0" | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=156 conv=notrunc status=none 2>/dev/null
printf "        " | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=148 conv=notrunc status=none 2>/dev/null
chksum=$(checksum "$tmp/header")
printf "%06o\000" "$chksum" | "$YF_SIGNIMAGE_DD" of="$tmp/header" bs=1 seek=148 conv=notrunc status=none 2>/dev/null
#######################################################################################################
#                                                                                                     #
# and append signature content and EoA blocks                                                         #
#                                                                                                     #
#######################################################################################################
cat "$tmp/header" "$tmp/signature"
"$YF_SIGNIMAGE_DD" if=/dev/zero bs=$(( 512 - sigsize )) count=1 status=none 2>/dev/null
cat "$tmp/1K.bin"
show_ok
#######################################################################################################
#                                                                                                     #
# all done, now STDOUT has seen all the needed data to be used as a signed image                      #
#                                                                                                     #
#######################################################################################################
exit 0
#######################################################################################################
#                                                                                                     #
# end of script                                                                                       #
#                                                                                                     #
#######################################################################################################
