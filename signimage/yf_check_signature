#! /bin/sh
# vim: set tabstop=4 syntax=sh :
# SPDX-License-Identifier: GPL-2.0-or-later WITH exceptions
#######################################################################################################
#                                                                                                     #
# verify signature of a sealed TAR archive                                                            #
#                                                                                                     #
###################################################################################################VER#
#                                                                                                     #
# yf_check_signature, version 1.0.1                                                                   #
#                                                                                                     #
# Some functions in this script were taken from the YourFritz Shell Script library (YF_SCRIPTLIB)     #
# and/or from YourFritz UI framework (YF_UI), which is a part of the YourFritz project from           #
# https://github.com/PeterPawn/YourFritz.                                                             #
#                                                                                                     #
###################################################################################################CPY#
#                                                                                                     #
# Copyright (C) 2016-2021 P. Haemmerlein (peterpawn@yourfritz.de)                                     #
#                                                                                                     #
###################################################################################################LIC#
#                                                                                                     #
# This script is licensed according to the following terms:                                           #
#                                                                                                     #
# This project is free software, you can redistribute it and/or modify it under the terms of the GNU  #
# General Public License as published by the Free Software Foundation; either version 2 of the        #
# License, or (at your option) any later version.                                                     #
#                                                                                                     #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without   #
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      #
# General Public License under http://www.gnu.org/licenses/gpl-2.0.html for more details.             #
#                                                                                                     #
# If you're including YF_UI functions in your own script(s) permanently, to deliver only one single   #
# file, you HAVE TO KEEP these functions together as one single continous part in your script AND     #
# this section HAS TO BE prefixed by its own header, like it's created by framework generator AND the #
# end of this section HAS TO BE marked clearly.                                                       #
#                                                                                                     #
# If you've changed anything to the content of UI functions, these changes HAVE TO BE marked with the #
# name of author AND the date of change AND a short explanation, what was changed (if it's not        #
# obvious).                                                                                           #
#                                                                                                     #
# In each case the copyright notice and licensing terms have to be kept as provided, but you may add  #
# your own copyright notice(s) and your own license conditions, as long as they're conforming to the  #
# rights granted by GPLv2 or later (with the exception above) and do not restrict or expand rights to #
# these parts of code, which are licensed under YourFritz conditions above.                           #
#                                                                                                     #
#################################################################################################EMBED#
#                                                                                                     #
# constants                                                                                           #
#                                                                                                     #
#######################################################################################################
avm_default_files="/etc/avm_firmware_public_key[1-9] plugin_global_key.pem"
eva_prompt="Eva_AVM"
box_key_name="/var/flash/websrv_ssl_key.pem"
box_cert_name1="/var/flash/websrv_ssl_cert.pem"
box_cert_name2="/var/tmp/websrv_ssl_cert.pem"
sig_file_content="signature"
sig_file_name="./var/signature"
urlader_environment_file="environment"
maca_name="maca"
eva_prompt="Eva_AVM"
public_keys_list="public_keys_to_consider"
tmp_pubkey="pubkey"
tar_toc="tar_members"
#######################################################################################################
#                                                                                                     #
# exit code definitions                                                                               #
#                                                                                                     #
#######################################################################################################
YF_CHECK_SIGNATURE_SUCCESS=0 # processing completed successfully
YF_CHECK_SIGNATURE_INVALID_OPTION=1 # unknown option specified
YF_CHECK_SIGNATURE_MISSING_ARGUMENTS=2 # missing arguments, usage screen shown
YF_CHECK_SIGNATURE_IMAGE_FILE_MISSING=3 # specified image file not found
YF_CHECK_SIGNATURE_MISSING_SIGNATURE=4 # specified image file doesn't contain a signature file (with proper name and path)
YF_CHECK_SIGNATURE_WRONG_SIGNATURE_SIZE=5 # the signature file has a wrong/unexpected size
YF_CHECK_SIGNATURE_FILE_NOT_FOUND=6 # a specified file does not exist
YF_CHECK_SIGNATURE_WRONG_PUBLIC_KEY=7 # none of the public keys could be used to decrypt signature file
YF_CHECK_SIGNATURE_INVALID_SIGNATURE_DATA=8 # invalid digest data found in signature file
YF_CHECK_SIGNATURE_UNSUPPORTED_HASH=10 # unsuppored hash algorithm was used to create the digest
YF_CHECK_SIGNATURE_NO_KEYS_DEFINED=11 # no public keys available for verification (may occur with -f option, if none of the lines has been accepted)
YF_CHECK_SIGNATURE_INVALID_DATA=12 # a specified public key file contains invalid data
YF_CHECK_SIGNATURE_NO_BUILTIN_KEYS=13 # no builtin keys available, it's not a FRITZ!OS device we're running on
YF_CHECK_SIGNATURE_NO_BOX_KEY=14 # unable to read box RSA key/certificate from /var/flash
YF_CHECK_SIGNATURE_NO_OSSL_BINARY=32 # no usable openssl binary found
YF_CHECK_SIGNATURE_NO_OSSL_DIGEST=33 # the openssl binary doesn't support the 'dgst' command
YF_CHECK_SIGNATURE_NO_OSSL_RSAUTIL=34 # the openssl binary doesn't support the 'rsautl' command
YF_CHECK_SIGNATURE_NO_OSSL_X509=35 # the openssl binary doesn't support the 'x509' command and it would be needed
YF_CHECK_SIGNATURE_VERIFICATION_FAILED=64 # signature verification wasn't successful
#######################################################################################################
#                                                                                                     #
# determine our script path to locate the configuration file                                          #
#                                                                                                     #
#######################################################################################################
my_path="$0"
[ "${my_path%/*}" = "$my_path" ] && my_path="." || my_path="${my_path%/*}"
# shellcheck disable=SC2034
my_name="${0##*/}"
#######################################################################################################
#                                                                                                     #
# include the configuration file, if it exists - only the definitions of external commands are used   #
#                                                                                                     #
#######################################################################################################
config_file="${YF_SIGNIMAGE_CONFIG:-$my_path/yf_signimage.conf}"
if [ -r "$config_file" ]; then
	# shellcheck source=./yf_signimage.conf
	. "$config_file"
fi
#######################################################################################################
#                                                                                                     #
# get the names of needed external commands, if called from any cross-device toolchain                #
#                                                                                                     #
#######################################################################################################
if [ -n "$YF_SIGNIMAGE_TAR" ]; then
	__YF_SIGNIMAGE_TAR="$YF_SIGNIMAGE_TAR"
	__yf_signimage_tar()
	{
		"$__YF_SIGNIMAGE_TAR" "$@"
	}
	YF_SIGNIMAGE_TAR="__yf_signimage_tar"
else
	YF_SIGNIMAGE_TAR="tar"
fi
if [ -n "$YF_SIGNIMAGE_DD" ]; then
	__YF_SIGNIMAGE_DD="$YF_SIGNIMAGE_DD"
	__yf_signimage_dd()
	{
		"$__YF_SIGNIMAGE_DD" "$@"
	}
	YF_SIGNIMAGE_DD="__yf_signimage_dd"
else
	YF_SIGNIMAGE_DD="dd"
fi
if [ -n "$YF_SIGNIMAGE_OPENSSL" ]; then
	__YF_SIGNIMAGE_OPENSSL="$YF_SIGNIMAGE_OPENSSL"
	__yf_signimage_openssl()
	{
		"$__YF_SIGNIMAGE_OPENSSL" "$@"
	}
	YF_SIGNIMAGE_OPENSSL="__yf_signimage_openssl"
else
	YF_SIGNIMAGE_OPENSSL="openssl"
fi
#######################################################################################################
#                                                                                                     #
# some subfunctions                                                                                   #
#                                                                                                     #
#######################################################################################################
show_error() ( printf "\033[1;31mFAILED\033[0m\a\n" 1>&2; )
show_ok() ( printf "\033[1;32mOK\033[0m\n" 1>&2; )
show_version()
(
	version=$("$YF_SIGNIMAGE_OPENSSL" version 2>/dev/null)
	if [ $? -eq 127 ]; then
		printf "\033[1;31mMissing \033[1;37mopenssl\033[1;31m binary, set \033[1;37mYF_SIGNIMAGE_OPENSSL\033[1;31m variable to its path name.\033[0m\a\n" 1>&2
		exit 1
	else
		printf "Found \033[1;34m%s\033[0m\n" "$version" 1>&2
		exit 0
	fi
)
__check_required_command()
(
	IFS=:
	set -- "$1"
	for n in "$@"; do
		command -v "$n" 2>/dev/null 1>&2 && exit 0
	done
	exit 1
)
__random()
(
	[ -f /proc/sys/kernel/random/uuid ] && cat /proc/sys/kernel/random/uuid && exit 0
	for h in md5sum sha1sum; do
		if __check_required_command $h; then
			if [ -c /dev/urandom ] && __check_required_command "dd"; then
				$YF_SIGNIMAGE_DD if=/dev/urandom bs=32 count=1 status=none 2>/dev/null | $h | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
			fi
			for f in /proc/self/stat /proc/self/status /proc/interrupts /proc/softirqs /proc/uptime; do
				if [ -f $f ]; then
					$h < $f | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
				fi
			done
		fi
	done
	__check_required_command "date" && date +%s && exit 0
	printf "%d" "$$"
)
__mktmp()
(
	if __check_required_command "mktemp"; then
		n="$(mktemp "$@" 2>/dev/null)"
	fi
	if [ -z "$n" ]; then
		t="${TMPDIR:-/tmp}"
		[ "$1" = "-d" ] && d=1 || d=0
		[ "$1" = "-p" ] && t="$2"
		[ -z "$t" ] && t="/tmp"
		n="$t/$(__random)"
		if [ $d -eq 1 ]; then
			[ -d "$n" ] && n="$t/$(__random)"
			mkdir -p "$n" 2>/dev/null
		else
			while [ -e "$n" ]; do
				n="$t/$(__random)"
			done
			touch "$n" 2>/dev/null
		fi
	fi
	printf "%s\n" "$n"
)
__hex2bin()
(
	__hex2bin_read_octal()
	{
		i=1
		h=1
		z=0
		# shellcheck disable=SC2162
		while read p l o; do
			[ "$i" -lt "$p" ] && return 1 # zero bytes on input stream are an error
			i=$(( i + 1 ))
			if [ "$o" -eq 11 ] || [ "$o" -eq 12 ] || [ "$o" -eq 15 ] || [ "$o" -eq 40 ]; then
				[ $h -eq 1 ] && continue || return 1 # whitespace after odd hex-digits
			fi
			if [ "$o" -ge 60 ] && [ "$o" -le 67 ]; then
				c=$(( o - 60 ))
			elif [ "$o" -ge 70 ] && [ "$o" -le 71 ]; then
				c=$(( o - 62 ))
			elif [ "$o" -ge 101 ] && [ "$o" -le 106 ]; then
				c=$(( o - 91 ))
			elif [ "$o" -ge 141 ] && [ "$o" -le 146 ]; then
				c=$(( o - 131 ))
			else
				return 1 # invalid character found
			fi
			if [ $h -eq 0 ]; then
				v=$(( v + c ))
				if [ $v -eq 0 ]; then
					z=$(( z + 1 )) # count consecutive zeros
				else
					if [ $z -gt 0 ]; then
						dd if=/dev/zero bs=$z count=1 2>/dev/null
						z=0
					fi
					printf "%b" "\0$(( v >> 6 ))$(( ( v >> 3 ) & 7 ))$(( v & 7 ))"
				fi
				h=1
			else
				v=$(( c * 16 ))
				h=0
			fi
		done
		[ $z -gt 0 ] && dd if=/dev/zero bs="$z" count=1 2>/dev/null
		return 0
	}

	command -v cmp 2>/dev/null 1>&2 || return 1
	command cmp -l -- /dev/zero - 2>/dev/null | __hex2bin_read_octal
	return $?
)
__yf_get_script_lines()
{
	sed -n -e "/^#*${1}#\$/,/^#\{20\}.*#\$/p" -- "$0" | \
	sed -e '1d;$d' | \
	sed -e 's|# \(.*\) *#$|\1|' | \
	sed -e 's|^#*#$|--|p' | \
	sed -e '$d' | \
	sed -e 's| *$||'
}
__yf_show_script_name()
{
	[ -n "$1" ] && printf -- '%s' "$1"
	printf -- '%s' "${0#*/}"
	[ -n "$1" ] && printf -- "\033[0m"
}
__yf_show_license()
{
	__yf_get_script_lines 'LIC'
}
__yf_show_version()
{
	printf "\n\033[1m%s\033[0m, %s\n" "$(__yf_get_script_lines 'VER' | sed -n -e "2s|^\([^,]*\),.*|\1|p")" "$(__yf_get_script_lines 'VER' | sed -n -e "2s|^[^,]*, \(.*\)|\1|p")"
}
__yf_show_copyright()
{
	__yf_get_script_lines 'CPY'
}
#######################################################################################################
#                                                                                                     #
# usage screen, caller has to redirect output to STDERR if needed                                     #
#                                                                                                     #
#######################################################################################################
ruler() { printf '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n';
          printf '00000000011111111112222222222333333333344444444445555555555666666666677777777778888888888999999999900000000001111111111\n';
          printf '1234+6789|1234+6789|1234+6789|1234+6789|1234+6789|1234+6789|1234+6789|1234+6789|1234+6789|1234+6789|1234+6789|1234+6789\n'; }
usage()
(
	__yf_show_version
	__yf_show_copyright
	__yf_show_license
	printf    "\nPurpose:\n\n\033[1mCheck, whether signature of an image file is valid.\033[0m\n\n"
	printf    "Usage:\n\n"
	printf    "\033[1;32m%s \033[0m" "$0"
	printf    "\033[1mimagefile\033[0m \033[1;34mpublic_keys\033[0m\n\n"
	printf    "\033[1mimagefile\033[0m is the archive to check (use a dash (-) for STDIN, the file will be saved to a temporary\n"
	printf    "location while the script is running) and the list of public keys to consider for decryption (the\n"
	printf    "\033[1;34mpublic_keys\033[0m part above) may be built from the following sources:\n\n"
	printf -- "-f \033[1mfilename\033[0m - add keys from files named in the specified file (one file per line), each file has to\n"
	printf    "              contain a key in AVM's format\n\n"
	printf -- "-b          - add the key files from current OS to the list, this option makes only sense, if the\n"
	printf    "              script is running on a FRITZ!OS-based device or in a proper emulation; an existing\n"
	printf    "              plugin signing key will be taken into account by this option, too\n\n"
	printf -- "-c \033[1mfilename\033[0m - add lines from specified file to the list, lines have to use the 'condensed' format\n"
	printf    "              (see below) and to provide at least a MOD and EXP value and (if the used exponent\n"
	printf    "              isn't the default 0x010001), SRC (optional) as a pseudo filename and DESC (optional,\n"
	printf    "              too) as a description to be displayed for this key (the DESC value is unused yet)\n\n"
	printf -- "-a \033[1mfilename\033[0m - add key from specified file (AVM's text format) to the list\n\n"
	printf -- "-p \033[1mfilename\033[0m - add key from specified file (PEM format) to the list\n\n"
	printf -- "-d \033[1mfilename\033[0m - add key from specified file (DER format) to the list\n\n"
	printf -- "-s          - verify that image file was signed with RSA key from local FRITZ!OS device (script is\n"
	printf    "              running on) - can't be combined with other key sources\n\n"
	printf    "The first key from specified sources (which are probed in the specified order) able to decode the\n"
	printf    "signature file will be used for signature verification.\n\n"
)
#######################################################################################################
#                                                                                                     #
# try to identify FRITZ!OS as runtime environment (not too sophisticated, but it should be able to    #
# make this distinction)                                                                              #
#                                                                                                     #
#######################################################################################################
is_fritzos_environment()
(
	# shellcheck disable=SC2154
	[ ${#HWRevision} -eq 0 ] && exit 1
	[ ${#CONFIG_ENVIRONMENT_PATH} -eq 0 ] && exit 1
	[ -d "$CONFIG_ENVIRONMENT_PATH" ] || exit 1
	[ -f "$CONFIG_ENVIRONMENT_PATH/$urlader_environment_file" ] || exit 1
	HWRev="$(sed -n -e "s|^HWRevision\t\(.*\)\$|\1|p" "$CONFIG_ENVIRONMENT_PATH/$urlader_environment_file")"
	[ ${#HWRev} -eq 0 ] && exit 1
	if [ "$HWRev" != "$HWRevision" ]; then
		if [ -z "$YF_SIGNIMAGE_IGNORE_HWREVISION" ]; then
			printf "\033[1;31mMismatch of \033[1;37mHWRevision\033[1;31m between shell and urlader environment (\033[1;37m%s\033[1;31m vs. \033[1;37m%s\033[1;31m).\033[0m\a\n" "$HWRev" "$HWRevision" 1>&2
			exit 1
		fi
		printf "\033[1;37mHWRevision\033[1;33m mismatch between shell and urlader environment (\033[1;37m%s\033[1;33m vs. \033[1;37m%s\033[1;33m) ignored.\033[0m\n" "$HWRev" "$HWRevision" 1>&2
	fi
	prompt="$(sed -n -e "s|^prompt\t\(.*\)\$|\1|p" "$CONFIG_ENVIRONMENT_PATH/$urlader_environment_file")"
	[ ${#prompt} -eq 0 ] && exit 1
	[ "$prompt" != "$eva_prompt" ] && exit 1
	exit 0
)
#######################################################################################################
#                                                                                                     #
# compute password of private key file from /var/flash/websrv_ssl_key.pem                             #
#                                                                                                     #
# meanwhile the cat was let out of the bag - no needs to use privatekeypassword anymore, instead      #
# we'll compute the hash ourself and translate it to the right string                                 #
#                                                                                                     #
#######################################################################################################
box_key_password()
(
	is_fritzos_environment || exit 1
	maca="$(sed -n -e "$(printf "s|^%s[ \t]*\(.*\)|\1|p" "$maca_name")" "$CONFIG_ENVIRONMENT_PATH/$urlader_environment_file")"
	if command -v md5sum 2>/dev/null 1>&2; then
		hash="$(printf "%s" "$maca" | md5sum)"
	else
		hash="$(printf "%s" "$maca" | "$YF_SIGNIMAGE_OPENSSL" dgst -md5 -r)"
	fi
	md5_bytes="$(printf "%s\n" "$hash" | sed -e "s|^\([0-9a-fA-F]\{16\}\).*|\1|" -e "s|..|& |g")"
	for b in $md5_bytes; do
		printf "%c" "$(expr 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!$' : ".\{$(( 0x$b % 64 ))\}\(.\).*")"
	done
	printf "\n"
	exit 0
)
#######################################################################################################
#                                                                                                     #
# output lines to use the builtin keys from the FRITZ!OS system, this script is running on - any      #
# further search will be skipped, if the environment does not match the usual characteristics of a    #
# FRITZ!Box router or a FRITZ!Repeater device                                                         #
#                                                                                                     #
#######################################################################################################
builtin_keys()
(
	is_fritzos_environment || exit 1
	for f in $avm_default_files; do
		if [ -f "$f" ]; then
			mod=$(sed -n -e "1p" "$f")
			exp=$(sed -n -e "2p" "$f")
			[ ${#exp} -eq 0 ] && exp=010001
			printf "DESC=\"current system\" SRC=\"%s\" MOD=%s EXP=%s\n" "$f" "$mod" "$exp"
		fi
	done
	exit 0
)
#######################################################################################################
#                                                                                                     #
# check, whether a valid modulus value was specified for RSA key size of 1024, 2048, 3072 or 4096 bit #
#                                                                                                     #
#######################################################################################################
check_modulus()
(
	[ -n "$(expr "$1" : ".*\([^0-9a-fA-F]\).*")" ] && exit 1
	for i in 256 512 768 1024; do
		[ ${#1} -eq $i ] && exit 0
		[ ${#1} -eq $(( i + 2 )) ] && [ "$(expr "$1" : "\(00\).*")" = "00" ] && exit 0
	done
	exit 1
)
#######################################################################################################
#                                                                                                     #
# check, whether the specified value is a hexadecimal string                                          #
#                                                                                                     #
#######################################################################################################
is_hexadecimal()
(
	[ -n "$(expr "$1" : ".*\([^0-9a-fA-F]\).*")" ] && exit 1
	[ $(( ${#1} % 2 )) -eq 0 ] && exit 0
	exit 1
)
#######################################################################################################
#                                                                                                     #
# convert modulus (and optional an exponent) from hexadecimal string to DER format, a version with    #
# comments regarding the structure and single steps may be found in yf_mod2der (a standalone script   #
# to convert from AVM's text representation to an ASN.1 encoded DER file)                             #
#                                                                                                     #
#######################################################################################################
modulus_to_der()
(
	mod="$1"
	exp="${2:-010001}"
	t_int=02
	t_seq=30
	t_bstr=03
	t_oid=06
	t_null=0500

	asn1_len()
	{
		x()
		{
			v=$1
			l=$(printf "%x" "$v")
			[ $(( ${#l} % 2 )) -ne 0 ] && l="0$l"
			printf "%s" "$l"
		}

		l=0
		v=$1
		l=$(( ${#v} / 2 ))
		if [ $l -gt 127 ]; then
			i=$(x $l)
			l=$(( ( ${#i} / 2 ) + 128 ))
			printf "%s" "$(x $l)$i"
		else
			printf "%s" "$(x $l)"
		fi
	}

	m_len="$t_int$(asn1_len "$mod")"
	e_len="$t_int$(asn1_len "$exp")"
	pk_c="$m_len$mod$e_len$exp"
	pk_len="$(asn1_len "$pk_c")"
	pk_seq="$t_seq$pk_len$pk_c"
	pk_bit="00$pk_seq"
	bits="$t_bstr$(asn1_len "$pk_bit")$pk_bit"
	oid="2A864886F70D010101"
	o_enc="$t_oid$(asn1_len "$oid")$oid"
	o_alg="$o_enc$t_null"
	o_seq="$t_seq$(asn1_len "$o_alg")$o_alg"
	der="$t_seq$(asn1_len "$o_seq$bits")"
	res="$der$o_seq$bits"
	printf "%s" "$res" | __hex2bin
	return $?
)
#######################################################################################################
#                                                                                                     #
# convert public key from PKCS#1 formats (DER or the base64 encoded DER -> PEM) according to RFC 8017 #
# (Appendix A.1.1) to our intermediate text format                                                    #
#                                                                                                     #
# seems like an unnecessary conversion, but it makes later handling easier, if we 'normalize' each    #
# possible public key in front of final search for the proper key                                     #
#                                                                                                     #
#######################################################################################################
pubkey_pkcs1_to_text()
(
	read_error() ( printf "\033[1;31mUnable to read RSA key (%s) from input file \033[1;37m%s\033[1;31m.\033[0m\a\n" "$format" "$file" 1>&2; )

	file="$1"
	format="$2"
	desc="${3:-$format key}"
	src="${4:-$file}"
	if ! line="$("$YF_SIGNIMAGE_OPENSSL" rsa -in "$file" -pubin -inform "$format" -modulus -noout 2>/dev/null)"; then
		read_error
		exit 1
	else
		MOD="$(printf "%s\n" "$line" | sed -n -e "s|^Modulus=\(.*\)|\1|p" | sed -e "y/ABCDEF/abcdef/")"
		if [ ${#MOD} -eq 0 ]; then
			read_error
			exit 1
		fi
		expr "$MOD" : "\([89a-f]\).*" 2>/dev/null 1>&2 && MOD="00$MOD"
		if ! "$YF_SIGNIMAGE_OPENSSL" rsa -in "$file" -pubin -inform "$format" -text -noout 2>/dev/null | \
		grep -q "^Exponent: 65537 (0x10001)\$" 2>/dev/null 1>&2; then # different exponent, read it from the output
			EXP=$("$YF_SIGNIMAGE_OPENSSL" rsa -in "$file" -pubin -inform "$format" -text -noout | \
			sed -n -e "s|^Exponent: [0-9]* (\(0x[0-9a-fA-F]*\))\$|\1|p")
			if [ ${#EXP} -eq 0 ]; then
				printf "\033[1;31mUnexpected output while reading exponent from public key file \033[1;37m%s\033[1;31m (%s).\033[0m\a\n" "$file" "$format" 1>&2
				exit 1
			fi
			EXP="$(printf "%016x" "$(( EXP ))")"
			while [ "$(expr "$EXP" : "\(.\).*")" = "0" ]; do
				EXP="$(expr "$EXP" : ".\(.*\)")"
			done
			[ $(( ${#EXP} % 2 )) -ne 0 ] && EXP="0$EXP"
		else
			EXP="010001"
		fi
		printf "DESC=\"%s\" SRC=\"%s\" MOD=%s EXP=%s\n" "$desc" "$src" "$MOD" "$EXP"
	fi
	exit 0
)
#######################################################################################################
#                                                                                                     #
# output the modulus from RSA key in /var/flash/websrv_ssl_key.pem to the list                        #
#                                                                                                     #
# We'll try to extract the modulus from the private key first, if we cannot read this key due to      #
# missing or wrong password, we'll extract it from the X.509 certificate in /var/flash or /var/tmp.   #
#                                                                                                     #
#######################################################################################################
read_box_key()
(
	printf "Trying to read public key from FRITZ!OS private key file (\033[1m%s\033[0m) ... " "$box_key_name" 1>&2
	if "$YF_SIGNIMAGE_OPENSSL" rsa -in $box_key_name -pubout -passin pass:"$(box_key_password)" -out "$tmp/$tmp_pubkey" 2>/dev/null; then
		pubkey_pkcs1_to_text "$tmp/$tmp_pubkey" PEM "box key" "FRITZ!OS RSA key" && show_ok && exit 0
		show_error
	fi
	show_error
	# try to use the certificate to get the public key
	printf "Check \033[1mx509\033[0m command ... " 1>&2
	if printf "" | "$YF_SIGNIMAGE_OPENSSL" x509 2>&1 | grep -q '^unable to load certificate' 2>/dev/null 1>&2; then
		show_ok
	else
		show_error
		exit $YF_CHECK_SIGNATURE_NO_OSSL_X509
	fi
	printf "Trying to read public key from \033[1m%s\033[0m ... " "$box_cert_name1" 1>&2
	if ! "$YF_SIGNIMAGE_OPENSSL" x509 -in "$box_cert_name1" -pubkey -noout >"$tmp/$tmp_pubkey" 2>/dev/null; then
		show_error
		printf "Trying to read public key from \033[1m%s\033[0m ... " "$box_cert_name2" 1>&2
		if ! "$YF_SIGNIMAGE_OPENSSL" x509 -in "$box_cert_name2" -pubkey -noout >"$tmp/$tmp_pubkey" 2>/dev/null; then
			show_error
			exit 1
		else
			show_ok
		fi
	else
		show_ok
	fi
	pubkey_pkcs1_to_text "$tmp/$tmp_pubkey" PEM "box certificate" "FRITZ!OS certificate"
)
#######################################################################################################
#                                                                                                     #
# TAR file handling functions                                                                         #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# use 'force-local' option with GNU TAR, if the image name contains a colon                           #
#                                                                                                     #
#######################################################################################################
tar_check_force_local()
(
	[ -n "$(expr "$1" : ".*\(:\).*")" ] && \
	"$YF_SIGNIMAGE_TAR" --help 2>&1 | grep -q 'force-local' 2>/dev/null && \
	printf -- "--force-local\n"
)
tar_create_table_of_contents()
(
	offset=0
	# shellcheck disable=SC2086,SC2162,SC2046
	"$YF_SIGNIMAGE_TAR" -t -v -f "$1" $(tar_check_force_local) | \
	sed -n -e "s|^[^ ]* *[^ ]* *\([0-9]*\) *[^ ]* *[^ ]* *\(.*\)\$|SIZE=\1 MEMBER=\2|p" | \
	while read line; do
		eval "$line"
		file_offset=$offset
		file_start=$(( file_offset + 512 ))
		file_end=$(( file_start + SIZE ))
		offset=$(( ( ( file_end + 511 ) / 512 ) * 512 ))
		printf "HEADER=%u START=%u END=%u SIZE=%u BLOCKS=%u MEMBER=\"%s\"\n" "$file_offset" "$file_start" "$file_end" "$SIZE" "$(( ( offset - file_offset ) / 512 ))" "$MEMBER"
	done
)
tar_get_member_data()
(
	# shellcheck disable=SC2046
	"$YF_SIGNIMAGE_TAR" -x -f "$1" -O $(tar_check_force_local "$1") "$2" 2>/dev/null
)
#######################################################################################################
#                                                                                                     #
# prepare a temporary directory and cleanup on exit                                                   #
#                                                                                                     #
#######################################################################################################
tmp=$(__mktmp -d)
trap 'rm -r \"$tmp\" 2>/dev/null 1>&2' EXIT HUP
#######################################################################################################
#                                                                                                     #
# check arguments and specified image file                                                            #
#                                                                                                     #
#######################################################################################################
if [ -z "$1" ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
	usage 1>&2
	[ -z "$1" ] && exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS || exit $YF_CHECK_SIGNATURE_SUCCESS
else
	image_file="$1"
	if [ "$image_file" = "-" ]; then
		image_file="$tmp/input_image"
		cat >"$image_file" 2>/dev/null
	fi
	shift
	if [ -z "$1" ]; then
		usage 1>&2
		exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
	fi
fi
if ! [ -f "$image_file" ]; then
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m does not exist.\033[0m\a\n" "$image_file" 1>&2
	exit $YF_CHECK_SIGNATURE_IMAGE_FILE_MISSING
fi
#######################################################################################################
#                                                                                                     #
# some output due to license terms                                                                    #
#                                                                                                     #
#######################################################################################################
__yf_show_version 1>&2
__yf_show_copyright 1>&2
printf "\nLicensed to you according to GPLv2 or a later version, with some additions.\nPlease refer to the usage screen for detailed license terms.\n\n" 1>&2
#######################################################################################################
#                                                                                                     #
# check OpenSSL presence and version                                                                  #
#                                                                                                     #
#######################################################################################################
show_version || exit $YF_CHECK_SIGNATURE_NO_OSSL_BINARY
cnf="$("$YF_SIGNIMAGE_OPENSSL" version 2>&1 | sed -n -e "s|WARNING: can't open config file: \(.*\)\$|\1|p")"
if [ -n "$cnf" ]; then # configuration file missing
	touch "$tmp/openssl.cnf"
	export OPENSSL_CONF="$tmp/openssl.cnf"
fi
printf "Check \033[1mdgst\033[0m command ... " 1>&2
if printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst 2>&1 | grep -q '^(stdin)=' 2>/dev/null 1>&2; then
	show_ok
else
	show_error
	exit $YF_CHECK_SIGNATURE_NO_OSSL_DIGEST
fi
printf "Check \033[1mrsautl\033[0m command ... " 1>&2
if printf "" | "$YF_SIGNIMAGE_OPENSSL" rsautl 2>&1 | grep -q '^no keyfile specified' 2>/dev/null 1>&2; then
	show_ok
else
	show_error
	exit $YF_CHECK_SIGNATURE_NO_OSSL_RSAUTIL
fi
#######################################################################################################
#                                                                                                     #
# build table of contents from provided image file                                                    #
#                                                                                                     #
#######################################################################################################
tar_create_table_of_contents "$image_file" >"$tmp/$tar_toc"
#######################################################################################################
#                                                                                                     #
# get the signature file from the image and check that it is in the expected format, before we waste  #
# a lot of time with checking an invalid signature file                                               #
#                                                                                                     #
#######################################################################################################
last_sig=0
i=0
# shellcheck disable=SC2162
while read line; do
	i=$(( i + 1 ))
	eval "$line"
	if [ "$MEMBER" = "$sig_file_name" ]; then
		last_sig=$i
	fi
done <"$tmp/$tar_toc"
if [ $last_sig -eq 0 ]; then
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m contains no signature file (\033[1;37m%s\033[1;31m).\033[0m\a\n" "$image_file" "$sig_file_name" 1>&2
	exit $YF_CHECK_SIGNATURE_MISSING_SIGNATURE
fi
eval "$(sed -n -e "${last_sig}p" "$tmp/$tar_toc")"
if [ "$SIZE" -eq 0 ] || [ "$SIZE" -gt 512 ]; then
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m contains an invalid signature file (\033[1;37m%s\033[1;31m).\033[0m\a\n" "$image_file" "$sig_file_name" 1>&2
	exit $YF_CHECK_SIGNATURE_WRONG_SIGNATURE_SIZE
fi
# shellcheck disable=SC2086
tar_get_member_data "$image_file" "$sig_file_name" "$tmp/$tar_toc" >"$tmp/$sig_file_content"
fs="$(wc -c < "$tmp/$sig_file_content")"
if [ "$fs" -ne 128 ] && [ "$fs" -ne 256 ] && [ "$fs" -ne 512 ]; then # signature size for 1024-, 2048- and 4096-bit keys
	printf "\033[1;31mThe specified image file \033[1;37m%s\033[1;31m contains an invalid signature file (\033[1;37m%s\033[1;31m).\033[0m\a\n" "$image_file" "$sig_file_name" 1>&2
	exit $YF_CHECK_SIGNATURE_WRONG_SIGNATURE_SIZE
fi
seek_image=$(( HEADER / 512 ))
#######################################################################################################
#                                                                                                     #
# copy the specified public keys from different sources to our temporary key list                     #
#                                                                                                     #
#######################################################################################################
touch "$tmp/$public_keys_list"
while [ "$#" -gt 0 ]; do
	case "$1" in
		"-f")
			if [ -z "$2" ]; then
				printf "\033[1;31mMissing filename after \033[1;37m-f\033[1;31m option.\033[0m\a\n" 1>&2
				exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
			fi
			if ! [ -f "$2" ] && ! [ -L "$2" ]; then
				printf "\033[1;31mThe specified public key files list \033[1;37m%s\033[1;31m does not exist.\033[0m\a\n" "$2" 1>&2
				exit $YF_CHECK_SIGNATURE_FILE_NOT_FOUND
			fi
			i=0
			# shellcheck disable=SC2162
			while read filename; do
				i=$(( i + 1 ))
				if [ -f "$filename" ]; then
					unset MOD
					unset EXP
					unset SRC
					unset DESC
					MOD=$(sed -n -e "1p" "$filename")
					if [ ${#MOD} -eq 0 ]; then
						printf "\033[1;33mUnable to read modulus value from file \033[1;37m%s\033[1;33m, which was included on line \033[1;37m%u\033[1;33m of file \033[1;37m%s\033[1;33m, file skipped.\033[0m\n" "$filename" "$i" "$2" 1>&2
						continue
					fi
					EXP=$(sed -n -e "2p" "$filename")
					[ ${#EXP} -eq 0 ] && EXP=010001
					DESC="$(printf "line %u of %s\n" "$i" "$2")"
					if ! check_modulus "$MOD"; then
						printf "\033[1;33mInvalid modulus value on line %u of file \033[1;37m%s\033[1;33m.\033[0m\n" "$i" "$2" 1>&2
						continue
					fi
					if ! is_hexadecimal "$EXP"; then
						printf "\033[1;33mInvalid exponent value on line %u of file \033[1;37m%s\033[1;33m.\033[0m\n" "$i" "$2" 1>&2
						continue
					fi
					printf "DESC=\"%s\" SRC=\"%s\" MOD=%s EXP=%s\n" "$DESC" "$filename" "$MOD" "$EXP" >>"$tmp/$public_keys_list"
				else
					printf "\033[1;33mFile \033[1;37m%s\033[1;33m from line \033[1;37m%u\033[1;33m of \033[1;37m%s\033[1;33m does not exist, line skipped.\033[0m\n" "$filename" "$i" "$2" 1>&2
				fi
			done <"$2"
			shift 2
			;;
		"-b")
			if ! builtin_keys >>"$tmp/$public_keys_list"; then
				printf "\033[1;31mThe option \033[1m-b\033[0m may only be used on a FRITZ!OS device.\033[0m\n" 1>&2
				exit $YF_CHECK_SIGNATURE_NO_BUILTIN_KEYS
			fi
			shift
			;;
		"-c")
			if [ -z "$2" ]; then
				printf "\033[1;31mMissing filename after \033[1;37m-c\033[1;31m option.\033[0m\a\n" 1>&2
				exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
			fi
			if ! [ -f "$2" ]; then
				printf "\033[1;31mThe specified public key file \033[1;37m%s\033[1;31m (condensed format) does not exist.\033[0m\a\n" "$2" 1>&2
				exit $YF_CHECK_SIGNATURE_FILE_NOT_FOUND
			fi
			i=0
			# shellcheck disable=SC2162
			while read line; do
				i=$(( i + 1 ))
				unset MOD
				unset EXP
				unset SRC
				unset DESC
				MOD="$(printf "%s\n" "$line" | sed -n -e "s|.*MOD=\([0-9a-fA-F]*\).*|\1|p")"
				EXP="$(printf "%s\n" "$line" | sed -n -e "s|.*EXP=\([0-9a-fA-F]*\).*|\1|p")"
				SRC="$(printf "%s\n" "$line" | sed -n -e "s|.*SRC=\"\([^\"]*\)\".*|\1|p")"
				DESC="$(printf "%s\n" "$line" | sed -n -e "s|.*DESC=\"\([^\"]*\)\".*|\1|p")"
				if [ -z "$MOD" ]; then
					printf "\033[1;31mMissing \033[1;37mMOD\033[1;31m value (modulus) on line %u of condensed file \033[1;37m%s\033[1;31m.\033[0m\a\n" "$i" "$2" 1>&2
					exit $YF_CHECK_SIGNATURE_INVALID_DATA
				elif [ -z "$EXP" ]; then
					EXP="010001"
				fi
				if [ -z "$DESC" ]; then
					# shellcheck disable=SC2031
					[ -n "$SRC" ] && DESC="$(printf "line %u of %2\n" "$i" "$2")" || DESC="$(printf "line %u\n" "$i")"
				fi
				# shellcheck disable=SC2031
				[ -n "$SRC" ] && SRC="$(printf "%s\n" "$2")"
				if ! check_modulus "$MOD"; then
					printf "\033[1;33mInvalid modulus value on line %u of file \033[1;37m%s\033[1;33m.\033[0m\n" "$i" "$2" 1>&2
					continue
				fi
				if ! is_hexadecimal "$EXP"; then
					printf "\033[1;33mInvalid exponent value on line %u of file \033[1;37m%s\033[1;33m.\033[0m\n" "$i" "$2" 1>&2
					continue
				fi
				printf "DESC=\"%s\" SRC=\"%s\" MOD=%s EXP=%s\n" "$DESC" "$SRC" "$MOD" "$EXP" >>"$tmp/$public_keys_list"
			done <"$2"
			shift 2
			;;
		"-a")
			if [ -z "$2" ]; then
				printf "\033[1;31mMissing filename after \033[1;37m-a\033[1;31m option.\033[0m\a\n" 1>&2
				exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
			fi
			if ! [ -f "$2" ]; then
				printf "\033[1;31mThe specified public key file \033[1;37m%s\033[1;31m (AVM format) does not exist.\033[0m\a\n" "$2" 1>&2
				exit $YF_CHECK_SIGNATURE_FILE_NOT_FOUND
			fi
			unset MOD
			unset EXP
			MOD="$(sed -n -e "1p" "$2")"
			EXP="$(sed -n -e "2p" "$2")"
			if [ ${#MOD} -gt 0 ]; then
				[ ${#EXP} -eq 0 ] && exp=010001
				if ! check_modulus "$MOD"; then
					printf "\033[1;33mInvalid modulus value on line 1 of file \033[1;37m%s\033[1;33m.\033[0m\n" "$2" 1>&2
					exit $YF_CHECK_SIGNATURE_INVALID_DATA
				fi
				if ! is_hexadecimal "$EXP"; then
					printf "\033[1;33mInvalid exponent value on line 2 of file \033[1;37m%s\033[1;33m.\033[0m\n" "$2" 1>&2
					exit $YF_CHECK_SIGNATURE_INVALID_DATA
				fi
				printf "DESC=\"text file from command line\" SRC=\"%s\" MOD=%s EXP=%s\n" "$2" "$MOD" "$EXP" >>"$tmp/$public_keys_list"
			else
				printf "\033[1;33mUnable to read modulus value from file \033[1;37m%s\033[1;33m, file skipped.\033[0m\n" "$filename" "$2" 1>&2
			fi
			shift 2
			;;
		"-p"|"-d")
			if [ -z "$2" ]; then
				printf "\033[1;31mMissing filename after \033[1;37m%s\033[1;31m option.\033[0m\a\n" "$1" 1>&2
				exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
			fi
			[ "$1" = "-p" ] && format="PEM" || format="DER"
			if ! [ -f "$2" ]; then
				printf "\033[1;31mThe specified public key file \033[1;37m%s\033[1;31m (%s format) does not exist.\033[0m\a\n" "$2" "$format" 1>&2
				exit $YF_CHECK_SIGNATURE_FILE_NOT_FOUND
			fi
			pubkey_pkcs1_to_text "$2" "$format" >>"$tmp/$public_keys_list" || exit $YF_CHECK_SIGNATURE_INVALID_DATA
			shift 2
			;;
		"-s")
			if [ -n "$2" ]; then
				printf "\033[1;31mExtra data specified after \033[1;37m%s\033[1;31m option.\033[0m\a\n" "$1" 1>&2
				exit $YF_CHECK_SIGNATURE_NO_BOX_KEY
			fi
			if ! is_fritzos_environment; then
				printf "\033[1;31mThe option \033[1;37m-s\033[1;31m may only be used on a FRITZ!OS device.\033[0m\a\n" 1>&2
				exit $YF_CHECK_SIGNATURE_NO_BOX_KEY
			fi
			if [ -s "$tmp/$public_keys_list" ]; then
				printf "\033[1;31mThe option \033[1;37m-s\033[1;31m may only be used without any other keys.\033[0m\a\n" 1>&2
				exit $YF_CHECK_SIGNATURE_INVALID_OPTION
			fi
			if ! read_box_key >>"$tmp/$public_keys_list"; then
				rc=$?
				printf "\033[1;31mUnable to read RSA key from FRITZ!OS device.\033[0m\n" 1>&2
				[ "$rc" -eq 1 ] && exit $YF_CHECK_SIGNATURE_NO_BOX_KEY || exit $rc
			fi
			shift
			;;
		*)
			printf "\033[1;31mUnknown option \033[1;37m%s\033[1;31m specified on command line.\033[0m\a\n" "$1" 1>&2
			exit $YF_CHECK_SIGNATURE_INVALID_OPTION
			;;
	esac
done
if ! [ -s "$tmp/$public_keys_list" ]; then
	printf "\033[1;31mNone of the specified public keys could be loaded.\033[0m\a\n" 1>&2
	exit $YF_CHECK_SIGNATURE_NO_KEYS_DEFINED
fi
#######################################################################################################
#                                                                                                     #
# find the public key corresponding to the private key, which was used to sign the image              #
#                                                                                                     #
#######################################################################################################
[ "$(wc -l <"$tmp/$public_keys_list")" -gt 1 ] && printf "Trying to determine the correct key now ...\n" 1>&2
key_found=0
# shellcheck disable=SC2162
while read line; do
	eval "$line"
	printf "Checking the public key from \033[1m%s\033[0m ... " "$SRC" 1>&2
	modulus_to_der "$MOD" "$EXP" >"$tmp/$tmp_pubkey"
	if output="$("$YF_SIGNIMAGE_OPENSSL" rsautl -verify -pubin -inkey "$tmp/$tmp_pubkey" -keyform der -asn1parse -in "$tmp/$sig_file_content" 2>&1)"; then
		key_found=1
		show_ok
		algo=$(printf "%s\n" "$output" | sed -n -e "s|^.*OBJECT.*:\(.*\)\$|\1|p" 2>/dev/null)
		if [ ${#algo} -gt 0 ]; then
			printf "Checking support for the used hash algorithm \033[1m%s\033[0m ... " "$algo" 1>&2
			if printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst -"$algo" 2>&1 2>/dev/null 1>&2; then
				show_ok
			else
				show_error
				exit $YF_CHECK_SIGNATURE_UNSUPPORTED_HASH
			fi
		else
			show_error
			exit $YF_CHECK_SIGNATURE_INVALID_SIGNATURE_DATA
		fi
	else
		show_error
	fi
done <"$tmp/$public_keys_list"
if [ $key_found -eq 0 ]; then
	printf "\033[1;31mNo usable public key was found.\033[0m\n" 1>&2
	exit $YF_CHECK_SIGNATURE_WRONG_PUBLIC_KEY
fi
#######################################################################################################
#                                                                                                     #
# now we check the signature with the openssl binary, we prepare the changed image file in a subshell #
# and pipe its output to openssl                                                                      #
#                                                                                                     #
#######################################################################################################
if ! res="$( ( "$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=$seek_image status=none 2>/dev/null;
	"$YF_SIGNIMAGE_DD" if=/dev/zero bs=512 count=2 status=none 2>/dev/null;
	"$YF_SIGNIMAGE_DD" if="$image_file" bs=512 skip=$(( seek_image + 2 )) status=none 2>/dev/null ) | \
	"$YF_SIGNIMAGE_OPENSSL" dgst -"$algo" -verify "$tmp/$tmp_pubkey" -keyform der -signature "$tmp/$sig_file_content")"; then
	printf "\033[1;31mSignature verification failed.\033[0m\n" 1>&2
	exit $YF_CHECK_SIGNATURE_VERIFICATION_FAILED
fi
#######################################################################################################
#                                                                                                     #
# all done                                                                                            #
#                                                                                                     #
#######################################################################################################
printf "\033[1;32mVerification succeeded.\033[0m\n" 1>&2
exit $YF_CHECK_SIGNATURE_SUCCESS
#######################################################################################################
#                                                                                                     #
# end of file                                                                                         #
#                                                                                                     #
#######################################################################################################
