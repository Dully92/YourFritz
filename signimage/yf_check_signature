#! /bin/sh
# vim: set tabstop=4 syntax=sh :
# SPDX-License-Identifier: GPL-2.0-or-later WITH exceptions
#######################################################################################################
#                                                                                                     #
# verify signature of a sealed TAR archive                                                            #
#                                                                                                     #
###################################################################################################VER#
#                                                                                                     #
# yf_check_signature, version 1.0.1                                                                   #
#                                                                                                     #
# Some functions in this script were taken from the YourFritz Shell Script library (YF_SCRIPTLIB)     #
# and/or from YourFritz UI framework (YF_UI), which is a part of the YourFritz project from           #
# https://github.com/PeterPawn/YourFritz.                                                             #
#                                                                                                     #
###################################################################################################CPY#
#                                                                                                     #
# Copyright (C) 2016-2021 P. Haemmerlein (peterpawn@yourfritz.de)                                     #
#                                                                                                     #
###################################################################################################LIC#
#                                                                                                     #
# This script is licensed according to the following terms:                                           #
#                                                                                                     #
# This project is free software, you can redistribute it and/or modify it under the terms of the GNU  #
# General Public License as published by the Free Software Foundation; either version 2 of the        #
# License, or (at your option) any later version.                                                     #
#                                                                                                     #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without   #
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      #
# General Public License under http://www.gnu.org/licenses/gpl-2.0.html for more details.             #
#                                                                                                     #
# If you're including YF_UI functions in your own script(s) permanently, to deliver only one single   #
# file, you HAVE TO KEEP these functions together as one single continous part in your script AND     #
# this section HAS TO BE prefixed by its own header, like it's created by framework generator AND the #
# end of this section HAS TO BE marked clearly.                                                       #
#                                                                                                     #
# If you've changed anything to the content of UI functions, these changes HAVE TO BE marked with the #
# name of author AND the date of change AND a short explanation, what was changed (if it's not        #
# obvious).                                                                                           #
#                                                                                                     #
# In each case the copyright notice and licensing terms have to be kept as provided, but you may add  #
# your own copyright notice(s) and your own license conditions, as long as they're conforming to the  #
# rights granted by GPLv2 or later (with the exception above) and do not restrict or expand rights to #
# these parts of code, which are licensed under YourFritz conditions above.                           #
#                                                                                                     #
#################################################################################################EMBED#
#                                                                                                     #
# constants                                                                                           #
#                                                                                                     #
#######################################################################################################
avm_default_files="/etc/avm_firmware_public_key[1-9] plugin_global_key.pem"
eva_prompt="Eva_AVM"
box_key_name="/var/flash/websrv_ssl_key.pem"
box_cert_name1="/var/flash/websrv_ssl_cert.pem"
box_cert_name2="/var/tmp/websrv_ssl_cert.pem"
sig_file_content="signature"
sig_file_name="./var/signature"
urlader_environment_file="environment"
maca_name="maca"
eva_prompt="Eva_AVM"
public_keys_list="public_keys_to_consider"
tmp_pubkey="pubkey"
tar_toc="tar_members"
YF_UI_LANGUAGES="en de"
#######################################################################################################
#                                                                                                     #
# exit code definitions                                                                               #
#                                                                                                     #
#######################################################################################################
YF_CHECK_SIGNATURE_SUCCESS=0 # processing completed successfully
YF_CHECK_SIGNATURE_INVALID_OPTION=1 # unknown option specified
YF_CHECK_SIGNATURE_MISSING_ARGUMENTS=2 # missing arguments, usage screen shown
YF_CHECK_SIGNATURE_IMAGE_FILE_MISSING=3 # specified image file not found
YF_CHECK_SIGNATURE_MISSING_SIGNATURE=4 # specified image file doesn't contain a signature file (with proper name and path)
YF_CHECK_SIGNATURE_WRONG_SIGNATURE_SIZE=5 # the signature file has a wrong/unexpected size
YF_CHECK_SIGNATURE_FILE_NOT_FOUND=6 # a specified file does not exist
YF_CHECK_SIGNATURE_WRONG_PUBLIC_KEY=7 # none of the public keys could be used to decrypt signature file
YF_CHECK_SIGNATURE_INVALID_SIGNATURE_DATA=8 # invalid digest data found in signature file
YF_CHECK_SIGNATURE_UNSUPPORTED_HASH=10 # unsuppored hash algorithm was used to create the digest
YF_CHECK_SIGNATURE_NO_KEYS_DEFINED=11 # no public keys available for verification (may occur with -f option, if none of the lines has been accepted)
YF_CHECK_SIGNATURE_INVALID_DATA=12 # a specified public key file contains invalid data
YF_CHECK_SIGNATURE_NO_BUILTIN_KEYS=13 # no builtin keys available, it's not a FRITZ!OS device we're running on
YF_CHECK_SIGNATURE_NO_BOX_KEY=14 # unable to read box RSA key/certificate from /var/flash
YF_CHECK_SIGNATURE_NO_OSSL_BINARY=32 # no usable openssl binary found
YF_CHECK_SIGNATURE_NO_OSSL_DIGEST=33 # the openssl binary doesn't support the 'dgst' command
YF_CHECK_SIGNATURE_NO_OSSL_RSAUTIL=34 # the openssl binary doesn't support the 'rsautl' command
YF_CHECK_SIGNATURE_NO_OSSL_X509=35 # the openssl binary doesn't support the 'x509' command and it would be needed
YF_CHECK_SIGNATURE_VERIFICATION_FAILED=64 # signature verification wasn't successful
#######################################################################################################
#                                                                                                     #
# determine our script path to locate the configuration file                                          #
#                                                                                                     #
#######################################################################################################
my_path="$0"
[ "${my_path%/*}" = "$my_path" ] && my_path="." || my_path="${my_path%/*}"
# shellcheck disable=SC2034
my_name="${0##*/}"
#######################################################################################################
#                                                                                                     #
# include the configuration file, if it exists - only the definitions of external commands are used   #
#                                                                                                     #
#######################################################################################################
config_file="${YF_SIGNIMAGE_CONFIG:-$my_path/yf_signimage.conf}"
if [ -r "$config_file" ]; then
	# shellcheck source=./yf_signimage.conf
	. "$config_file"
fi
#######################################################################################################
#                                                                                                     #
# get the names of needed external commands, if called from any cross-device toolchain                #
#                                                                                                     #
#######################################################################################################
if [ -n "$YF_SIGNIMAGE_DD" ]; then
	__YF_SIGNIMAGE_DD="$YF_SIGNIMAGE_DD"
	__yf_signimage_dd()
	{
		"$__YF_SIGNIMAGE_DD" "$@"
	}
	YF_SIGNIMAGE_DD="__yf_signimage_dd"
else
	YF_SIGNIMAGE_DD="dd"
fi
if [ -n "$YF_SIGNIMAGE_OPENSSL" ]; then
	__YF_SIGNIMAGE_OPENSSL="$YF_SIGNIMAGE_OPENSSL"
	__yf_signimage_openssl()
	{
		"$__YF_SIGNIMAGE_OPENSSL" "$@"
	}
	YF_SIGNIMAGE_OPENSSL="__yf_signimage_openssl"
else
	YF_SIGNIMAGE_OPENSSL="openssl"
fi
#######################################################################################################
#                                                                                                     #
# some subfunctions                                                                                   #
#                                                                                                     #
#######################################################################################################
show_error()
(
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized ERR_show_error)" 1>&2
)

show_ok()
(
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized INF_show_ok)" 1>&2
)
show_version()
(
	version=$("$YF_SIGNIMAGE_OPENSSL" version 2>/dev/null)
	if [ $? -eq 127 ]; then
		# shellcheck disable=SC2059
		printf "$(__yf_get_localized ERR_missing_openssl)" 1>&2
		exit 1
	else
		# shellcheck disable=SC2059
		printf "$(__yf_get_localized INF_ossl_version)" "$version" 1>&2
		exit 0
	fi
)
#######################################################################################################
#######################################################################################################
##                                                                                                   ##
##   Y o u r F r i t z   s h e l l   s c r i p t    l i b r ar y   a n d   Y o u r F r i t z   U I   ##
##                                                                                                   ##
#######################################################################################################
#######################################################################################################
__yf_check_required_command()
(
	IFS=:
	set -- "$1"
	for n in "$@"; do
		command -v "$n" 2>/dev/null 1>&2 && exit 0
	done
	exit 1
)

__yf_ansi_sgr() { printf -- '\033[%sm' "$1"; }
__yf_ansi_bold__="$(__yf_ansi_sgr 1)"
__yf_ansi_underline__="$(__yf_ansi_sgr 4)"
__yf_ansi_black__="$(__yf_ansi_sgr 30)"
__yf_ansi_red__="$(__yf_ansi_sgr 31)"
__yf_ansi_green__="$(__yf_ansi_sgr 32)"
__yf_ansi_yellow__="$(__yf_ansi_sgr 33)"
__yf_ansi_blue__="$(__yf_ansi_sgr 34)"
__yf_ansi_magenta__="$(__yf_ansi_sgr 35)"
__yf_ansi_cyan__="$(__yf_ansi_sgr 36)"
__yf_ansi_white__="$(__yf_ansi_sgr 37)"
__yf_ansi_gray__="$(__yf_ansi_sgr 90)"
__yf_ansi_bright_red__="$(__yf_ansi_sgr 91)"
__yf_ansi_bright_green__="$(__yf_ansi_sgr 92)"
__yf_ansi_bright_yellow__="$(__yf_ansi_sgr 93)"
__yf_ansi_bright_blue__="$(__yf_ansi_sgr 94)"
__yf_ansi_bright_magenta__="$(__yf_ansi_sgr 95)"
__yf_ansi_bright_cyan__="$(__yf_ansi_sgr 96)"
__yf_ansi_bright_white__="$(__yf_ansi_sgr 97)"
__yf_ansi_reset__="$(__yf_ansi_sgr 0)"
__yf_bold() { printf -- "%s" "$__yf_ansi_bold__"; printf -- "%s" "$@"; printf -- "%s" "$__yf_ansi_reset__"; }
__yf_undl() { printf -- "%s" "$__yf_ansi_underline__"; printf -- "%s" "$@"; printf -- "%s" "$__yf_ansi_reset__"; }

__yf_escape_specials() { printf -- '%s\n' "$1" | sed -e 's|[";()$`\\]|\\&|g'; }
__yf_escape_strings() { printf -- '%s\n' "$1" | sed -e 's|" $\\]|\\&|g'; }

__yf_languages__="${YF_UI_LANGUAGES:-en}"
__yf_get_language()
(
	__yf_get_language_code()
	{
		printf -- '%s\n' "$1" | sed -n -e '1s|^\([A-Za-z]*\).*|\1|p' | sed -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'
	}

	___yf_lang="$1"
	shift

	if [ -n "$Language" ]; then
		___yf_check="$(__yf_get_language_code "$Language")"
	elif [ -n "$LC_ALL" ]; then
		___yf_check="$(__yf_get_language_code "$LC_ALL")"
	else
		[ -z "$LANG" ] || ___yf_check="$(__yf_get_language_code "$LANG")"
	fi
	if [ -n "$___yf_check" ]; then
		[ "$___yf_lang" = "$___yf_check" ] || \
		for ___yf_lng in "$@"; do
			[ "$___yf_lng" = "$___yf_check" ] && ___yf_lang="$___yf_lng" && break
		done
	fi
	printf -- '%s' "${___yf_lang:-en}"
	unset ___yf_lng
	unset ___yf_lang
	unset ___yf_check
)
__yf_language__="$(eval __yf_get_language "$__yf_languages__")"
__yf_internal_get_localized()
(
	eval ___yf_msg="\${__YF_L10N_INT_$1_${__yf_language__}}"
	[ -z "$___yf_msg" ] && ___yf_lang="en" || ___yf_lang="$__yf_language__"
	eval ___yf_msg="\${__YF_L10N_INT_$1_${___yf_lang}}"
	eval printf -- '%s' "\"$___yf_msg\""
	unset ___yf_msg
	unset ___yf_lang
)
__yf_get_localized()
(
	eval ___yf_msg="\${__YF_L10N_$1_${__yf_language__}}"
	[ -z "$___yf_msg" ] && ___yf_lang="en" || ___yf_lang="$__yf_language__"
	eval ___yf_msg="\${__YF_L10N_$1_${___yf_lang}}"
	[ -z "$___yf_msg" ] && printf -- "Message definition '%s' is missing for '%s'.\n" "$1" "$__yf_language__" 1>&2 && return
	printf -- '%s' "$___yf_msg"
	unset ___yf_msg
	unset ___yf_lang
)
__yf_declare_internal_message()
{
	___yf_msg_lang="$1"
	___yf_msg_code="$2"
	shift 2
	printf -- '__YF_L10N_INT_%s_%s=\"%s\"\n' "$___yf_msg_code" "$___yf_msg_lang" "$(__yf_escape_strings "$@")"
	unset ___yf_msg_lang
	unset ___yf_msg_code
}
__yf_int_msg()
{
	__yf_declare_internal_message "$@"
}

__yf_declare_message()
{
	___yf_msg_lang="$1"
	if [ "${#___yf_msg_lang}" -ne 2 ]; then
		___yf_msg_lang='en'
		___yf_msg_code="$1"
		shift
	else
		___yf_msg_code="$2"
		shift 2
	fi
	printf -- '__YF_L10N_%s_%s="%s"\n' "$___yf_msg_code" "$___yf_msg_lang" "$(__yf_escape_strings "$@")"
	unset ___yf_msg_lang
	unset ___yf_msg_code
}
__yf_msg()
{
	__yf_declare_message "$@"
}

__yf_random()
(
	[ -f /proc/sys/kernel/random/uuid ] && cat /proc/sys/kernel/random/uuid && exit 0
	for h in md5sum sha1sum; do
		if __yf_check_required_command $h; then
			if [ -c /dev/urandom ] && __yf_check_required_command "dd"; then
				$YF_SIGNIMAGE_DD if=/dev/urandom bs=32 count=1 status=none 2>/dev/null | $h | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
			fi
			for f in /proc/self/stat /proc/self/status /proc/interrupts /proc/softirqs /proc/uptime; do
				if [ -f $f ]; then
					$h < $f | sed -n -e "s|^\([0-9A-Fa-f]*\).*\$|\1|p" && exit 0
				fi
			done
		fi
	done
	__yf_check_required_command "date" && date +%s && exit 0
	printf "%d" "$$"
)
__yf_mktmp()
(
	if __yf_check_required_command "mktemp"; then
		n="$(mktemp "$@" 2>/dev/null)"
	fi
	if [ -z "$n" ]; then
		t="${TMPDIR:-/tmp}"
		[ "$1" = "-d" ] && d=1 || d=0
		[ "$1" = "-p" ] && t="$2"
		[ -z "$t" ] && t="/tmp"
		n="$t/$(__yf_random)"
		if [ $d -eq 1 ]; then
			[ -d "$n" ] && n="$t/$(__yf_random)"
			mkdir -p "$n" 2>/dev/null
		else
			while [ -e "$n" ]; do
				n="$t/$(__yf_random)"
			done
			touch "$n" 2>/dev/null
		fi
	fi
	printf "%s\n" "$n"
)
__yf_hex2bin()
(
	__yf_hex2bin_read_octal()
	{
		i=1
		h=1
		z=0
		# shellcheck disable=SC2162
		while read p l o; do
			[ "$i" -lt "$p" ] && return 1 # zero bytes on input stream are an error
			i=$(( i + 1 ))
			if [ "$o" -eq 11 ] || [ "$o" -eq 12 ] || [ "$o" -eq 15 ] || [ "$o" -eq 40 ]; then
				[ $h -eq 1 ] && continue || return 1 # whitespace after odd hex-digits
			fi
			if [ "$o" -ge 60 ] && [ "$o" -le 67 ]; then
				c=$(( o - 60 ))
			elif [ "$o" -ge 70 ] && [ "$o" -le 71 ]; then
				c=$(( o - 62 ))
			elif [ "$o" -ge 101 ] && [ "$o" -le 106 ]; then
				c=$(( o - 91 ))
			elif [ "$o" -ge 141 ] && [ "$o" -le 146 ]; then
				c=$(( o - 131 ))
			else
				return 1 # invalid character found
			fi
			if [ $h -eq 0 ]; then
				v=$(( v + c ))
				if [ $v -eq 0 ]; then
					z=$(( z + 1 )) # count consecutive zeros
				else
					if [ $z -gt 0 ]; then
						dd if=/dev/zero bs=$z count=1 2>/dev/null
						z=0
					fi
					printf "%b" "\0$(( v >> 6 ))$(( ( v >> 3 ) & 7 ))$(( v & 7 ))"
				fi
				h=1
			else
				v=$(( c * 16 ))
				h=0
			fi
		done
		[ $z -gt 0 ] && dd if=/dev/zero bs="$z" count=1 2>/dev/null
		return 0
	}

	command -v cmp 2>/dev/null 1>&2 || return 1
	command cmp -l -- /dev/zero - 2>/dev/null | __yf_hex2bin_read_octal
	return $?
)
__yf_get_script_lines()
{
	sed -n -e "/^#*${1}#\$/,/^#\{20\}.*#\$/p" -- "$0" | \
	sed -e '1d;$d' | \
	sed -e 's|# \(.*\) *#$|\1|' | \
	sed -e 's|^#*#$|--|p' | \
	sed -e '$d' | \
	sed -e 's| *$||'
}
__yf_show_script_name()
{
	[ -n "$1" ] && printf -- '%s' "$1"
	printf -- '%s' "${0#*/}"
	[ -n "$1" ] && printf -- "%s" "${__yf_ansi_reset__}"
}
__yf_show_license()
{
	__yf_get_script_lines 'LIC'
}
__yf_show_version()
{
	printf "\n${__yf_ansi_bold__}%s${__yf_ansi_reset__}, %s\n" "$(__yf_get_script_lines 'VER' | sed -n -e "2s|^\([^,]*\),.*|\1|p")" "$(__yf_get_script_lines 'VER' | sed -n -e "2s|^[^,]*, \(.*\)|\1|p")"
}
__yf_show_copyright()
{
	__yf_get_script_lines 'CPY'
}
#######################################################################################################
#######################################################################################################
##                                                                                                   ##
##  D o n ' t   c h a n g e   a n y t h i n g   a b o v e   t h i s   p o i n t.                     ##
##                                                                                                   ##
##  ( u p   t o   t h e   f i r s t   m a r k )                                                      ##
##                                                                                                   ##
#######################################################################################################
#######################################################################################################

#######################################################################################################
#                                                                                                     #
# messages - english                                                                                  #
#                                                                                                     #
#######################################################################################################
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_license'					'\nLicensed to you according to GPLv2 or a later version, with some additions.\nPlease refer to the usage screen for detailed license terms.\n\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_show_error'				'${__yf_ansi_red__}FAILED${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_show_ok'					'${__yf_ansi_green__}OK${__yf_ansi_reset__}\n')"

# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_ossl_version'			'Found version: ${__yf_ansi_bright_blue__}%s${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_read_box_privkey'		'Trying to read public key from FRITZ!OS private key file (${__yf_ansi_bold__}%s${__yf_ansi_reset__}) ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_read_box_cert'			'Trying to read public key from ${__yf_ansi_bold__}%s${__yf_ansi_reset__} ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_check_command'			'Check ${__yf_ansi_bold__}%s${__yf_ansi_reset__} command ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_verify_success'			'${__yf_ansi_green__}Verification succeeded.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_public_key_check'		'Checking the public key from ${__yf_ansi_bold__}%s${__yf_ansi_reset__} ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_check_supported_hash'	'Checking support for the used hash algorithm ${__yf_ansi_bold__}%s${__yf_ansi_reset__} ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'INF_probing_keys'			'Trying to determine the correct key now ...\n')"

# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_missing_openssl'			'${__yf_ansi_red__}Missing ${__yf_ansi_white__}openssl${__yf_ansi_red__} binary, set ${__yf_ansi_white__}YF_SIGNIMAGE_OPENSSL${__yf_ansi_red__} variable to its path name.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_RSA_key'					'${__yf_ansi_red__}Unable to read RSA key (%s) from input file ${__yf_ansi_white__}%s${__yf_ansi_red__}.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_unexpected_EXP'			'${__yf_ansi_red__}Unexpected output while reading exponent from public key file ${__yf_ansi_white__}%s${__yf_ansi_red__} (%s).${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_missing_file_for_option' '${__yf_ansi_red__}Missing filename after ${__yf_ansi_white__}%s${__yf_ansi_red__} option.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_missing_file_with_list'  '${__yf_ansi_red__}The specified public key files list ${__yf_ansi_white__}%s${__yf_ansi_red__} does not exist.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_no_fritzos_device'		'${__yf_ansi_red__}The option ${__yf_ansi_white__}%s${__yf_ansi_red__} may only be used on a FRITZ!OS device.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_pubkey_file_missing'		'${__yf_ansi_red__}The specified public key file ${__yf_ansi_white__}%s${__yf_ansi_red__} (%s) does not exist.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'PART_condensed'				'condensed format')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'PART_avmformat'				'AVM''s format')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'PART_pkcs1'					'%s format')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_too_much_options'		'${__yf_ansi_red__}The option ${__yf_ansi_white__}%s${__yf_ansi_red__} may only be used without any other keys.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_missing_variable_name'	'${__yf_ansi_red__}Missing variable name after ${__yf_ansi_white__}%s${__yf_ansi_red__} option.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_no_public_keys'			'${__yf_ansi_red__}None of the specified public keys could be loaded.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_wrong_public_keys'		'${__yf_ansi_red__}No usable public key was found.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_verify_failed'			'${__yf_ansi_red__}Signature verification failed.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_image_missing'			'${__yf_ansi_red__}The specified image file ${__yf_ansi_white__}%s${__yf_ansi_red__} does not exist.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_no_signature_found'		'${__yf_ansi_red__}The specified image file ${__yf_ansi_white__}%s${__yf_ansi_red__} contains no signature file (${__yf_ansi_white__}%s${__yf_ansi_red__}).${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_invalid_signature_file'	'${__yf_ansi_red__}The specified image file ${__yf_ansi_white__}%s${__yf_ansi_red__} contains an invalid signature file (${__yf_ansi_white__}%s${__yf_ansi_red__}).${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_missing_env_value'		'${__yf_ansi_yellow__}The specified environment variable ${__yf_ansi_white__}%s${__yf_ansi_yellow__} is missing or has an empty value.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_unknown_option'			'${__yf_ansi_red__}Unknown option ${__yf_ansi_white__}%s${__yf_ansi_red__} specified on command line.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_invalid_modulus'			'${__yf_ansi_yellow__}Invalid modulus value on line ${__yf_ansi_white__}%u${__yf_ansi_yellow__} of file ${__yf_ansi_white__}%s${__yf_ansi_yellow__}.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_too_much_arguments'		'${__yf_ansi_red__}Extra data specified after ${__yf_ansi_white__}%s${__yf_ansi_red__} option.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_invalid_exponent'		'${__yf_ansi_yellow__}Invalid exponent value on line ${__yf_ansi_white__}%u${__yf_ansi_yellow__} of file ${__yf_ansi_white__}%s${__yf_ansi_yellow__}.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_file_read_error'			'${__yf_ansi_yellow__}Unable to read modulus value from file ${__yf_ansi_white__}%s${__yf_ansi_yellow__}, which was included on line ${__yf_ansi_white__}%u${__yf_ansi_yellow__} of file ${__yf_ansi_white__}%s${__yf_ansi_yellow__}, file skipped.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_file_missing_error'		'${__yf_ansi_yellow__}File ${__yf_ansi_white__}%s${__yf_ansi_yellow__} from line ${__yf_ansi_white__}%u${__yf_ansi_yellow__} of ${__yf_ansi_white__}%s${__yf_ansi_yellow__} does not exist, line skipped.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_missing_modulus'			'${__yf_ansi_red__}Missing ${__yf_ansi_white__}MOD${__yf_ansi_red__} value (modulus) on line ${__yf_ansi_white__}%u${__yf_ansi_red__} of condensed file ${__yf_ansi_white__}%s${__yf_ansi_red__}.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_modulus_read_error'		'${__yf_ansi_yellow__}Unable to read modulus value from file ${__yf_ansi_white__}%s${__yf_ansi_yellow__}, file skipped.${__yf_ansi_reset__}\n')"
#######################################################################################################
#                                                                                                     #
# messages - german                                                                                   #
#                                                                                                     #
#######################################################################################################
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_license'					'\nLizenziert nach den Bestimmungen der GPLv2 oder einer höheren Version, mit ein paar Zusätzen.\nEinzelheiten sind dem Hilfe-Bildschirm (in englischer Sprache) zu entnehmen.\n\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_show_error'				'${__yf_ansi_red__}FEHLER${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_show_ok'					'${__yf_ansi_green__}OK${__yf_ansi_reset__}\n')"

# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_ossl_version'			'Gefundene Version: ${__yf_ansi_bright_blue__}%s${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_read_box_privkey'		'Versuche den öffentlichen Schlüssel aus der privaten Schlüsseldatei im FRITZ!OS zu extrahieren (${__yf_ansi_bold__}%s${__yf_ansi_reset__}) ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_read_box_cert'			'Versuche den öffentlichen Schlüssel aus dem Zertifikat in ${__yf_ansi_bold__}%s${__yf_ansi_reset__} im FRITZ!OS zu extrahieren ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_check_command'			'Prüfe Verfügbarkeit des ${__yf_ansi_bold__}%s${__yf_ansi_reset__}-Kommandos ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_verify_success'			'${__yf_ansi_green__}Die Signaturprüfung war erfolgreich.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_public_key_check'		'Prüfung des öffentlichen Schlüssels von ${__yf_ansi_bold__}%s${__yf_ansi_reset__} ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_check_supported_hash'	'Prüfung der Unterstützung des verwendeten Hash-Algorithmus ${__yf_ansi_bold__}%s${__yf_ansi_reset__} ... ')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'INF_probing_keys'			'Suche nach dem passenden öffentlichen Schlüssel ...\n')"

# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_missing_openssl'			'${__yf_ansi_red__}Es fehlt die Datei für ${__yf_ansi_white__}openssl${__yf_ansi_red__}, bitte die ${__yf_ansi_white__}YF_SIGNIMAGE_OPENSSL${__yf_ansi_red__}-Einstellung auf den Pfad zu diesem Kommando setzen.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_RSA_key'					'${__yf_ansi_red__}Der RSA-Schlüssel (%s) kann nicht aus der Datei ${__yf_ansi_white__}%s${__yf_ansi_red__} gelesen werden.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_unexpected_EXP'			'${__yf_ansi_red__}Unerwartetes Ergebnis beim Versuch, den Exponenten des öffentlichen Schlüssels aus der Datei ${__yf_ansi_white__}%s${__yf_ansi_red__} (%s) zu lesen.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_missing_file_for_option' '${__yf_ansi_red__}Die Angabe eines Dateinamens nach der Option ${__yf_ansi_white__}%s${__yf_ansi_red__} fehlt.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_missing_file_with_list'  '${__yf_ansi_red__}Die angegebene Datei ${__yf_ansi_white__}%s${__yf_ansi_red__} für die Liste mit Namen von Schlüsseldateien existiert nicht.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_no_fritzos_device'		'${__yf_ansi_red__}Die Option ${__yf_ansi_white__}-b${__yf_ansi_red__} kann nur auf einem Gerät mit FRITZ!OS von AVM genutzt werden.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_pubkey_file_missing'		'${__yf_ansi_red__}Die angegebene Datei ${__yf_ansi_white__}%s${__yf_ansi_red__} mit öffentlichen Schlüsseln (%s) existiert nicht.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'PART_condensed'				'komprimiertes Format')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'PART_avmformat'				'AVM-(Text-)Format')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'PART_pkcs1'					'%s-Format')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_too_much_options'		'${__yf_ansi_red__}Die Option ${__yf_ansi_white__}%s${__yf_ansi_red__} kann nicht mit weiteren Optionen/Schlüsseln kombiniert werden.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_read_RSA_box_key'		'${__yf_ansi_red__}Der RSA-Schlüssel der FRITZ!OS konnte nicht gelesen werden.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_missing_variable_name'	'${__yf_ansi_red__}Der Name der Environment-Variablen fehlt nach der Option ${__yf_ansi_white__}%s${__yf_ansi_red__}.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_no_public_keys'			'${__yf_ansi_red__}Es ist kein öffentlicher Schlüssel für die Prüfung der Signatur verfügbar.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_wrong_public_keys'		'${__yf_ansi_red__}Es konnte kein passender öffentlicher Schlüssel gefunden werden.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_verify_failed'			'${__yf_ansi_red__}Die Signaturprüfung ist fehlgeschlagen.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_image_missing'			'${__yf_ansi_red__}Die angegebene Image-Datei ${__yf_ansi_white__}%s${__yf_ansi_red__} existiert nicht.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_no_signature_found'		'${__yf_ansi_red__}Die angegebene Image-Datei ${__yf_ansi_white__}%s${__yf_ansi_red__} enthält keine Signatur (${__yf_ansi_white__}%s${__yf_ansi_red__}).${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_invalid_signature_file'	'${__yf_ansi_red__}Die angegebene Image-Datei ${__yf_ansi_white__}%s${__yf_ansi_red__} enthält eine Signatur-Datei mit ungültigem Aufbau (${__yf_ansi_white__}%s${__yf_ansi_red__}).${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_missing_env_value'		'${__yf_ansi_yellow__}Die angegebene Environment-Variable ${__yf_ansi_white__}%s${__yf_ansi_yellow__} ist nicht gesetzt oder der Wert ist leer (Länge 0).${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_unknown_option'			'${__yf_ansi_red__}Die Option ${__yf_ansi_white__}%s${__yf_ansi_red__} is unbekannt.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_invalid_modulus'			'${__yf_ansi_yellow__}Ungültige Daten für den Wert des Modulus in Zeile ${__yf_ansi_white__}%u${__yf_ansi_yellow__} der Datei ${__yf_ansi_white__}%s${__yf_ansi_yellow__}.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_too_much_arguments'		'${__yf_ansi_red__}Zusätzliche Argumente angegeben nach der Option ${__yf_ansi_white__}%s${__yf_ansi_red__}.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_invalid_exponent'		'${__yf_ansi_yellow__}Ungültige Daten für den Wert des Exponenten in Zeile ${__yf_ansi_white__}%u${__yf_ansi_yellow__} der Datei ${__yf_ansi_white__}%s${__yf_ansi_yellow__}.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_file_read_error'			'${__yf_ansi_yellow__}Der Modulus-Wert konnte nicht aus der Datei ${__yf_ansi_white__}%s${__yf_ansi_yellow__}, die in Zeile ${__yf_ansi_white__}%u${__yf_ansi_yellow__} der Datei ${__yf_ansi_white__}%s${__yf_ansi_yellow__} hinzugefügt werden sollte, gelesen werden - die Datei wurde ignoriert.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'de' 'ERR_file_missing_error'		'${__yf_ansi_yellow__}Die Datei ${__yf_ansi_white__}%s${__yf_ansi_yellow__}, die in Zeile ${__yf_ansi_white__}%u${__yf_ansi_yellow__} der Datei ${__yf_ansi_white__}%s${__yf_ansi_yellow__} hinzugefügt werden sollte, wurde nicht gefunden - die Zeile wurde ignoriert.${__yf_ansi_reset__}\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_missing_modulus'			'${__yf_ansi_red__}Der Wert für ${__yf_ansi_white__}MOD${__yf_ansi_red__} (den Modulus des öffentlichen Schlüssels) fehlt in Zeile ${__yf_ansi_white__}%u${__yf_ansi_red__} der zusammengefassten Datei ${__yf_ansi_white__}%s${__yf_ansi_red__}.${__yf_ansi_reset__}\a\n')"
# shellcheck disable=SC2016
eval "$(__yf_msg 'en' 'ERR_modulus_read_error'		'${__yf_ansi_yellow__}Der Modulus-Wert konnte nicht aus der Datei ${__yf_ansi_white__}%s${__yf_ansi_yellow__} gelesen werden, die Datei wurde ignoriert.${__yf_ansi_reset__}\n')"
#######################################################################################################
#                                                                                                     #
# usage screen, caller has to redirect output to STDERR if needed                                     #
#                                                                                                     #
#######################################################################################################
usage()
(
	if [ "$__yf_language__" = "de" ]; then
		__yf_show_version
		__yf_show_copyright
		__yf_show_license
		printf    "\nEine deutsche Version des oben stehenden Textes findet man - nach der Übersetzung des Textes der\n"
		printf    "Lizenzbestimmungen - unter dieser Adresse im Internet: https://www.gnu.de/documents/gpl-2.0.de.html\n"
		# shellcheck disable=SC2059
		printf    "\nZweck:\n\n${__yf_ansi_bold__}Prüfen, ob die Signatur in einem TAR-Image (nach AVM-Manier) gültig ist.${__yf_ansi_reset__}\n\n"
		printf    "Aufruf:\n\n"
		# shellcheck disable=SC2059
		printf    "${__yf_ansi_green__}%s ${__yf_ansi_reset__}" "$0"
		# shellcheck disable=SC2059
		printf    "${__yf_ansi_bold__}imagefile${__yf_ansi_reset__} ${__yf_ansi_bright_blue__}public_keys${__yf_ansi_reset__}\n\n"
		# shellcheck disable=SC2059
		printf    "${__yf_ansi_bold__}imagefile${__yf_ansi_reset__} ist die zu prüfende Image-Datei, bei Angabe eines Bindestrichs (-) wird der Inhalt der\n"
		printf    "Standardeingabe (STDIN) in eine temporäre Datei geschrieben und im weiteren Verlauf dann diese\n"
		printf    "verwendet.\n\n"
		# shellcheck disable=SC2059
		printf    "Nach dem Namen der Image-Datei kann mittels folgender Optionen festgelegt werden (als ${__yf_ansi_bright_blue__}public_keys${__yf_ansi_reset__}),\n"
		printf    "welche öffentlichen RSA-Schlüssel eine gültige Signatur erstellt haben könnten:\n\n"
		# shellcheck disable=SC2059
		printf -- "-a ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - die Datei ${__yf_ansi_bold__}filename${__yf_ansi_reset__} enthält einen öffentlichen Schlüssel im AVM-Format, wobei es sich\n"
		printf    "              um eine Textdatei handelt, welche in der ersten Zeile den Modulus-Wert als hexadezi-\n"
		printf    "              male Zeichenkette enthält und in der zweiten Zeile den verwendeten Exponenten\n"
		printf    "              (üblicherweise 65537, ebenfalls als hexadezimale Zeichenkette: 010001)\n\n"
		# shellcheck disable=SC2059
		printf -- "-f ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - die Datei ${__yf_ansi_bold__}filename${__yf_ansi_reset__} enthält pro Zeile den Namen einer Datei, die (in demselben Format,\n"
		printf    "              welches auch AVM verwendet, s.o.) einen potentiellen öffentlichen Schlüssel enthält\n\n"
		# shellcheck disable=SC2059
		printf -- "-c ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - die Datei ${__yf_ansi_bold__}filename${__yf_ansi_reset__} enthält pro Zeile die Angaben für einen öffentlichen Schlüssel,\n"
		printf    "              wobei die Daten jeweils aus einem Name-/Wert-Paar bestehen, mit folgenden Namen:\n\n"
		printf    "              MOD  - der Modulus des Schlüssels (diese Angabe MUSS vorhanden sein in der Zeile)\n"
		printf    "              EXP  - der verwendete Exponent (fehlt die Angabe, wird wieder 65537 angenommen)\n"
		printf    "              SRC  - wird als Name der Datei angezeigt, wenn der Schlüssel verarbeitet wird, der\n"
		printf    "                     Wert MUSS in doppelte Anführungszeichen (\") eingeschlossen sein\n"
		printf    "              DESC - kann zusätzliche Informationen zu diesem Schlüssel enthalten, z.B. woher er\n"
		printf    "                     stammt; die Angabe wird derzeit noch nicht verwendet, der Wert MUSS aber auch\n"
		printf    "                     in doppelte Anführungszeichen (\") eingeschlossen sein, wenn er vorhanden ist\n\n"
		printf    "              Die Werte für SRC und DESC dürfen selbst kein doppeltes Anführungszeichen enthalten,\n"
		printf    "              es gibt auch keine Möglichkeit, ein solches zu 'maskieren' im Wert.\n\n"
		# shellcheck disable=SC2059
		printf -- "-e ${__yf_ansi_bold__}variable${__yf_ansi_reset__} - die angegebene ${__yf_ansi_bold__}variable${__yf_ansi_reset__} im Shell-Environment enthält den Modulus eines öffentlichen\n"
		printf    "              Schlüssels, der Exponent wird fix als 65537 angenommen\n\n"
		# shellcheck disable=SC2059
		printf -- "-p ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - die Datei ${__yf_ansi_bold__}filename${__yf_ansi_reset__} enthält einen PKCS#1-kodierten öffentlichen Schlüssel im PEM-\n"
		printf    "              Format (Base64-kodiertes DER-Format)\n\n"
		# shellcheck disable=SC2059
		printf -- "-d ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - die Datei ${__yf_ansi_bold__}filename${__yf_ansi_reset__} enthält einen PKCS#1-kodierten öffentlichen Schlüssel im DER-\n"
		printf    "              Format\n\n"
		printf    "Wird dieses Skript auf einem Gerät mit FRITZ!OS von AVM ausgeführt, stehen auch noch diese beiden\n"
		printf    "Optionen zur Auswahl:\n\n"
		printf -- "-b          - alle öffentlichen Schlüssel aus dem laufenden FRITZ!OS werden der Liste potentieller\n"
		# shellcheck disable=SC2059
		printf    "              Schlüssel hinzugefügt, die Dateien befinden sich im Verzeichnis ${__yf_ansi_bold__}/etc${__yf_ansi_reset__} und haben die\n"
		# shellcheck disable=SC2059
		printf    "              Namen ${__yf_ansi_bold__}avm_firmware_public_key[1-9]${__yf_ansi_reset__} bzw. ${__yf_ansi_bold__}plugin_global_key.pem${__yf_ansi_reset__}\n\n"
		# shellcheck disable=SC2059
		printf -- "-s          - es wird ausschließlich der öffentliche Schlüssel akzeptiert, der zu dem privaten\n"
		# shellcheck disable=SC2059
		printf    "              Schlüssel des Gerätes (in ${__yf_ansi_bold__}/var/flash/websrv_ssl_key.pem${__yf_ansi_reset__}) gehört, dieser wird ggf.\n"
		# shellcheck disable=SC2059
		printf    "              auch noch in der Datei ${__yf_ansi_bold__}/var/flash/websrv_ssl_cert.pem${__yf_ansi_reset__} bzw. danach noch in der\n"
		# shellcheck disable=SC2059
		printf    "              ${__yf_ansi_bold__}/var/tmp/websrv_ssl_cert.pem${__yf_ansi_reset__} gesucht, wenn er zuvor nicht gefunden wurde (für das\n"
		# shellcheck disable=SC2059
		printf    "              Auslesen des Wertes aus einem der beiden Zertifikate muß das vorhandene ${__yf_ansi_bold__}OpenSSL${__yf_ansi_reset__}-\n"
		# shellcheck disable=SC2059
		printf    "              Programm zusätzlich das Kommando ${__yf_ansi_bold__}x509${__yf_ansi_reset__} unterstützen); die Option ${__yf_ansi_bold__}-s${__yf_ansi_reset__} kann nicht mit\n"
		printf    "              anderen Optionen kombiniert werden\n\n"
		printf    "Der erste öffentliche Schlüssel, mit dem sich die Signatur-Datei in der angegebenen Image-Datei\n"
		printf    "entschlüsseln läßt (sie werden in der Reihenfolge der Angaben beim Aufruf geprüft), wird danach\n"
		printf    "benutzt, um den Hash-Wert in der Signatur mit dem berechneten Hash-Wert über den restlichen Inhalt\n"
		printf    "der Image-Datei zu vergleichen.\n\n"
	else
		__yf_show_version
		__yf_show_copyright
		__yf_show_license
		# shellcheck disable=SC2059
		printf    "\nPurpose:\n\n${__yf_ansi_bold__}Check, whether signature of an image file is valid.${__yf_ansi_reset__}\n\n"
		printf    "Usage:\n\n"
		# shellcheck disable=SC2059
		printf    "${__yf_ansi_green__}%s ${__yf_ansi_reset__}" "$0"
		# shellcheck disable=SC2059
		printf    "${__yf_ansi_bold__}imagefile${__yf_ansi_reset__} ${__yf_ansi_bright_blue__}public_keys${__yf_ansi_reset__}\n\n"
		# shellcheck disable=SC2059
		printf    "${__yf_ansi_bold__}imagefile${__yf_ansi_reset__} is the archive to check, if specified as a dash (-), STDIN stream will be saved to a\n"
		printf    "temporary location while the script is running.\n\n"
		# shellcheck disable=SC2059
		printf    "The list of public keys to consider for decryption (the ${__yf_ansi_bright_blue__}public_keys${__yf_ansi_reset__} part above) may be built from\n"
		printf    "the following sources:\n\n"
		# shellcheck disable=SC2059
		printf -- "-a ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - add key from specified file (containing a key in AVM's text format) to the list, the\n"
		printf    "              file has to contain two lines with hexadecimal strings, where the first line\n"
		printf    "              represents the modulus value and the second one the exponent\n\n"
		# shellcheck disable=SC2059
		printf -- "-f ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - add keys from files named in the specified file (one file per line), each file has to\n"
		printf    "              contain a key in AVM's format (see above)\n\n"
		# shellcheck disable=SC2059
		printf -- "-c ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - add lines from specified file to the list, lines have to use a text format with\n"
		printf    "              key/value pairs to provide at least a MOD and EXP value (if the used exponent isn't\n"
		printf    "              the default 65537), SRC (optional) as a pseudo filename and DESC (optional, too) as a\n"
		printf    "              description to be displayed for this key (the DESC value is unused yet)\n\n"
		# shellcheck disable=SC2059
		printf -- "-e ${__yf_ansi_bold__}variable${__yf_ansi_reset__} - add modulus from specified environment variable (hexadecimal string) with a fixed\n"
		printf    "              exponent of 0x010001\n\n"
		# shellcheck disable=SC2059
		printf -- "-p ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - add key from specified file (PEM format) to the list\n\n"
		# shellcheck disable=SC2059
		printf -- "-d ${__yf_ansi_bold__}filename${__yf_ansi_reset__} - add key from specified file (DER format) to the list\n\n"
		printf    "If the script is running from a FRITZ!OS-based device, the following options are available, too:\n\n"
		printf -- "-b          - add key files from current OS to the list\n\n"
		printf -- "-s          - verify that image file was signed with RSA key from local FRITZ!OS device - this\n"
		printf    "              option can't be combined with other options\n\n"
		printf    "The first key from specified sources (which are probed in the specified order) able to decode the\n"
		printf    "signature file will be used for signature verification.\n\n"
	fi
)
#######################################################################################################
#                                                                                                     #
# try to identify FRITZ!OS as runtime environment (not too sophisticated, but it should be able to    #
# make this distinction)                                                                              #
#                                                                                                     #
#######################################################################################################
is_fritzos_environment()
(
	# shellcheck disable=SC2154
	[ ${#HWRevision} -eq 0 ] && exit 1
	[ ${#CONFIG_ENVIRONMENT_PATH} -eq 0 ] && exit 1
	[ -d "$CONFIG_ENVIRONMENT_PATH" ] || exit 1
	[ -f "$CONFIG_ENVIRONMENT_PATH/$urlader_environment_file" ] || exit 1
	HWRev="$(sed -n -e "s|^HWRevision\t\(.*\)\$|\1|p" "$CONFIG_ENVIRONMENT_PATH/$urlader_environment_file")"
	[ ${#HWRev} -eq 0 ] && exit 1
	prompt="$(sed -n -e "s|^prompt\t\(.*\)\$|\1|p" "$CONFIG_ENVIRONMENT_PATH/$urlader_environment_file")"
	[ ${#prompt} -eq 0 ] && exit 1
	[ "$prompt" != "$eva_prompt" ] && exit 1
	exit 0
)
#######################################################################################################
#                                                                                                     #
# compute password of private key file from /var/flash/websrv_ssl_key.pem                             #
#                                                                                                     #
# meanwhile the cat was let out of the bag - no needs to use privatekeypassword anymore, instead      #
# we'll compute the hash ourself and translate it to the right string                                 #
#                                                                                                     #
#######################################################################################################
box_key_password()
(
	is_fritzos_environment || exit 1
	maca="$(sed -n -e "$(printf "s|^%s[ \t]*\(.*\)|\1|p" "$maca_name")" "$CONFIG_ENVIRONMENT_PATH/$urlader_environment_file")"
	if command -v md5sum 2>/dev/null 1>&2; then
		hash="$(printf "%s" "$maca" | md5sum)"
	else
		hash="$(printf "%s" "$maca" | "$YF_SIGNIMAGE_OPENSSL" dgst -md5 -r)"
	fi
	md5_bytes="$(printf "%s\n" "$hash" | sed -e "s|^\([0-9a-fA-F]\{16\}\).*|\1|" -e "s|..|& |g")"
	for b in $md5_bytes; do
		printf "%c" "$(expr 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!$' : ".\{$(( 0x$b % 64 ))\}\(.\).*")"
	done
	printf "\n"
	exit 0
)
#######################################################################################################
#                                                                                                     #
# output lines to use the builtin keys from the FRITZ!OS system, this script is running on - any      #
# further search will be skipped, if the environment does not match the usual characteristics of a    #
# FRITZ!Box router or a FRITZ!Repeater device                                                         #
#                                                                                                     #
#######################################################################################################
builtin_keys()
(
	is_fritzos_environment || exit 1
	for f in $avm_default_files; do
		if [ -f "$f" ]; then
			mod=$(sed -n -e "1p" "$f")
			exp=$(sed -n -e "2p" "$f")
			[ ${#exp} -eq 0 ] && exp=010001
			printf "DESC=\"current system\" SRC=\"%s\" MOD=%s EXP=%s\n" "$f" "$mod" "$exp"
		fi
	done
	exit 0
)
#######################################################################################################
#                                                                                                     #
# check, whether a valid modulus value was specified for RSA key size of 1024, 2048, 3072 or 4096 bit #
#                                                                                                     #
#######################################################################################################
check_modulus()
(
	[ -n "$(expr "$1" : ".*\([^0-9a-fA-F]\).*")" ] && exit 1
	for i in 256 512 768 1024; do
		[ ${#1} -eq $i ] && exit 0
		[ ${#1} -eq $(( i + 2 )) ] && [ "$(expr "$1" : "\(00\).*")" = "00" ] && exit 0
	done
	exit 1
)
#######################################################################################################
#                                                                                                     #
# check, whether the specified value is a hexadecimal string                                          #
#                                                                                                     #
#######################################################################################################
is_hexadecimal()
(
	[ -n "$(expr "$1" : ".*\([^0-9a-fA-F]\).*")" ] && exit 1
	[ $(( ${#1} % 2 )) -eq 0 ] && exit 0
	exit 1
)
#######################################################################################################
#                                                                                                     #
# convert modulus (and optional an exponent) from hexadecimal string to DER format, a version with    #
# comments regarding the structure and single steps may be found in yf_mod2der (a standalone script   #
# to convert from AVM's text representation to an ASN.1 encoded DER file)                             #
#                                                                                                     #
#######################################################################################################
modulus_to_der()
(
	mod="$1"
	exp="${2:-010001}"
	t_int=02
	t_seq=30
	t_bstr=03
	t_oid=06
	t_null=0500

	asn1_len()
	{
		x()
		{
			v=$1
			l=$(printf "%x" "$v")
			[ $(( ${#l} % 2 )) -ne 0 ] && l="0$l"
			printf "%s" "$l"
		}

		l=0
		v=$1
		l=$(( ${#v} / 2 ))
		if [ $l -gt 127 ]; then
			i=$(x $l)
			l=$(( ( ${#i} / 2 ) + 128 ))
			printf "%s" "$(x $l)$i"
		else
			printf "%s" "$(x $l)"
		fi
	}

	m_len="$t_int$(asn1_len "$mod")"
	e_len="$t_int$(asn1_len "$exp")"
	pk_c="$m_len$mod$e_len$exp"
	pk_len="$(asn1_len "$pk_c")"
	pk_seq="$t_seq$pk_len$pk_c"
	pk_bit="00$pk_seq"
	bits="$t_bstr$(asn1_len "$pk_bit")$pk_bit"
	oid="2A864886F70D010101"
	o_enc="$t_oid$(asn1_len "$oid")$oid"
	o_alg="$o_enc$t_null"
	o_seq="$t_seq$(asn1_len "$o_alg")$o_alg"
	der="$t_seq$(asn1_len "$o_seq$bits")"
	res="$der$o_seq$bits"
	printf "%s" "$res" | __hex2bin
	return $?
)
#######################################################################################################
#                                                                                                     #
# convert public key from PKCS#1 formats (DER or the base64 encoded DER -> PEM) according to RFC 8017 #
# (Appendix A.1.1) to our intermediate text format                                                    #
#                                                                                                     #
# seems like an unnecessary conversion, but it makes later handling easier, if we 'normalize' each    #
# possible public key in front of final search for the proper key                                     #
#                                                                                                     #
#######################################################################################################
pubkey_pkcs1_to_text()
(
	read_error()
	(
		# shellcheck disable=SC2059
		printf "$(__yf_get_localized ERR_RSA_key)" "$format" "$file" 1>&2
	)

	file="$1"
	format="$2"
	desc="${3:-$format key}"
	src="${4:-$file}"
	if ! line="$("$YF_SIGNIMAGE_OPENSSL" rsa -in "$file" -pubin -inform "$format" -modulus -noout 2>/dev/null)"; then
		read_error
		exit 1
	else
		MOD="$(printf "%s\n" "$line" | sed -n -e "s|^Modulus=\(.*\)|\1|p" | sed -e "y/ABCDEF/abcdef/")"
		if [ ${#MOD} -eq 0 ]; then
			read_error
			exit 1
		fi
		expr "$MOD" : "\([89a-f]\).*" 2>/dev/null 1>&2 && MOD="00$MOD"
		if ! "$YF_SIGNIMAGE_OPENSSL" rsa -in "$file" -pubin -inform "$format" -text -noout 2>/dev/null | \
		grep -q "^Exponent: 65537 (0x10001)\$" 2>/dev/null 1>&2; then # different exponent, read it from the output
			EXP=$("$YF_SIGNIMAGE_OPENSSL" rsa -in "$file" -pubin -inform "$format" -text -noout | \
			sed -n -e "s|^Exponent: [0-9]* (\(0x[0-9a-fA-F]*\))\$|\1|p")
			if [ ${#EXP} -eq 0 ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_unexpected_exp)" "$file" "$format" 1>&2
				exit 1
			fi
			EXP="$(printf "%016x" "$(( EXP ))")"
			while [ "$(expr "$EXP" : "\(.\).*")" = "0" ]; do
				EXP="$(expr "$EXP" : ".\(.*\)")"
			done
			[ $(( ${#EXP} % 2 )) -ne 0 ] && EXP="0$EXP"
		else
			EXP="010001"
		fi
		printf "DESC=\"%s\" SRC=\"%s\" MOD=%s EXP=%s\n" "$desc" "$src" "$MOD" "$EXP"
	fi
	exit 0
)
#######################################################################################################
#                                                                                                     #
# output the modulus from RSA key in /var/flash/websrv_ssl_key.pem to the list                        #
#                                                                                                     #
# We'll try to extract the modulus from the private key first, if we cannot read this key due to      #
# missing or wrong password, we'll extract it from the X.509 certificate in /var/flash or /var/tmp.   #
#                                                                                                     #
#######################################################################################################
read_box_key()
(
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized INF_read_box_privkey)" "$box_key_name" 1>&2
	if "$YF_SIGNIMAGE_OPENSSL" rsa -in $box_key_name -pubout -passin pass:"$(box_key_password)" -out "$tmp/$tmp_pubkey" 2>/dev/null; then
		pubkey_pkcs1_to_text "$tmp/$tmp_pubkey" PEM "box key" "FRITZ!OS RSA key" && show_ok && exit 0
		show_error
	fi
	show_error
	# try to use the certificate to get the public key
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized INF_check_command)" "x509" 1>&2
	if printf "" | "$YF_SIGNIMAGE_OPENSSL" x509 2>&1 | grep -q '^unable to load certificate' 2>/dev/null 1>&2; then
		show_ok
	else
		show_error
		exit $YF_CHECK_SIGNATURE_NO_OSSL_X509
	fi
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized INF_read_box_cert)" "$box_cert_name1" 1>&2
	if ! "$YF_SIGNIMAGE_OPENSSL" x509 -in "$box_cert_name1" -pubkey -noout >"$tmp/$tmp_pubkey" 2>/dev/null; then
		show_error
		# shellcheck disable=SC2059
		printf "$(__yf_get_localized INF_read_box_cert)" "$box_cert_name2" 1>&2
		if ! "$YF_SIGNIMAGE_OPENSSL" x509 -in "$box_cert_name2" -pubkey -noout >"$tmp/$tmp_pubkey" 2>/dev/null; then
			show_error
			exit 1
		else
			show_ok
		fi
	else
		show_ok
	fi
	pubkey_pkcs1_to_text "$tmp/$tmp_pubkey" PEM "box certificate" "FRITZ!OS certificate"
)
#######################################################################################################
#                                                                                                     #
# TAR file handling functions                                                                         #
#                                                                                                     #
#######################################################################################################
tar_create_table_of_contents()
(
	block_no=0
	max_block=$(( $(wc -c < "$1") / 512 ))
	magic="$(__yf_mktmp -p "$tmp")"
	empty="$(__yf_mktmp -p "$tmp")"
	printf "ustar" >"$magic"
	dd if=/dev/zero bs=512 count=1 status=none >"$empty"
	while [ "$block_no" -lt "$max_block" ]; do
		if dd if="$1" bs=512 skip="$block_no" count=1 status=none | dd bs=1 skip=257 count=5 status=none | cmp -s "$magic" -; then
			name="$(dd if="$1" bs=512 skip="$block_no" count=1 status=none | dd bs=1 skip=0 count=100 status=none | tr -d '\000')"
			[ "${#name}" -gt 99 ] && exit 3 # name too long
			size="$(dd if="$1" bs=512 skip="$block_no" count=1 status=none | dd bs=1 skip=124 count=12 status=none | tr -d '\000')"
			size=$(( 0$size ))
			type="$(dd if="$1" bs=512 skip="$block_no" count=1 status=none | dd bs=1 skip=156 count=1 status=none | tr -d '\000')"
			[ ${#type} -eq 0 ] && type=0
			{ ! [ "$type" = "0" ] && ! [ "$type" = "5" ]; } && exit 2 # invalid type of entry
			printf "HEADER=%u START=%u END=%u SIZE=%u BLOCKS=%u TYPE=%s MEMBER=\"%s\"\n" "$(( block_no * 512 ))" "$(( ( block_no + 1 ) * 512 ))" "$(( ( ( block_no + 1 ) * 512 ) + size ))" "$size" "$(( ( size + 511 ) / 512 ))" "$type" "$name"
			block_no=$(( block_no + 1 + ( ( size + 511 ) / 512 ) ))
		else
			! dd if="$1" bs=512 skip="$block_no" count=1 status=none | cmp -s "$empty" - && exit 1
			[ $block_no -lt 1 ] && exit 1
			block_no=$(( block_no + 1 ))
		fi
	done
)
tar_get_member_data()
(
	if [ -z "$3" ]; then
		toc="$(__yf_mktmp -p "$tmp")"
		tar_create_table_of_contents "$1" >"$toc"
	else
		toc="$3"
	fi
	# shellcheck disable=SC2162
	while read line; do
		eval "$line"
		if [ "$2" = "$MEMBER" ]; then
			if [ "$BLOCKS" -gt 1 ]; then
				dd if="$1" bs=512 skip=$(( START / 512 )) count=$(( BLOCKS - 1 )) status=none
			fi
			# shellcheck disable=SC2153
			dd if="$1" bs=512 skip=$(( ( START / 512 ) + BLOCKS - 1 )) count=1 status=none | \
			dd bs=1 count=$(( SIZE % 512 )) status=none
			exit 0
		fi
	done <"$toc"
	exit 1
)
#######################################################################################################
#                                                                                                     #
# prepare a temporary directory and cleanup on exit                                                   #
#                                                                                                     #
#######################################################################################################
tmp=$(__yf_mktmp -d)
trap 'rm -r "$tmp" 2>/dev/null 1>&2' EXIT HUP
if [ -n "$DEBUG_MESSAGES" ]; then # show all defined messages and exit
	set | grep "^__YF_L10N" 1>&2
	exit 0
fi
#######################################################################################################
#                                                                                                     #
# check arguments and specified image file                                                            #
#                                                                                                     #
#######################################################################################################
if [ -z "$1" ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
	usage 1>&2
	[ -z "$1" ] && exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS || exit $YF_CHECK_SIGNATURE_SUCCESS
else
	image_file="$1"
	if [ "$image_file" = "-" ]; then
		image_file="$tmp/input_image"
		cat >"$image_file" 2>/dev/null
	fi
	shift
	if [ -z "$1" ]; then
		usage 1>&2
		exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
	fi
fi
if ! [ -f "$image_file" ]; then
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized ERR_image_missing)" "$image_file" 1>&2
	exit $YF_CHECK_SIGNATURE_IMAGE_FILE_MISSING
fi
#######################################################################################################
#                                                                                                     #
# some output due to license terms                                                                    #
#                                                                                                     #
#######################################################################################################
__yf_show_version 1>&2
__yf_show_copyright 1>&2
# shellcheck disable=SC2059
printf "$(__yf_get_localized INF_license)" 1>&2
#######################################################################################################
#                                                                                                     #
# check OpenSSL presence and version                                                                  #
#                                                                                                     #
#######################################################################################################
show_version || exit $YF_CHECK_SIGNATURE_NO_OSSL_BINARY
cnf="$("$YF_SIGNIMAGE_OPENSSL" version 2>&1 | sed -n -e "s|WARNING: can't open config file: \(.*\)\$|\1|p")"
if [ -n "$cnf" ]; then # configuration file missing
	touch "$tmp/openssl.cnf"
	export OPENSSL_CONF="$tmp/openssl.cnf"
fi
# shellcheck disable=SC2059
printf "$(__yf_get_localized INF_check_command)" "dgst" 1>&2
if printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst 2>&1 | grep -q '^(stdin)=' 2>/dev/null 1>&2; then
	show_ok
else
	show_error
	exit $YF_CHECK_SIGNATURE_NO_OSSL_DIGEST
fi
# shellcheck disable=SC2059
printf "$(__yf_get_localized INF_check_command)" "rsautl" 1>&2
if printf "" | "$YF_SIGNIMAGE_OPENSSL" rsautl 2>&1 | grep -q '^no keyfile specified' 2>/dev/null 1>&2; then
	show_ok
else
	show_error
	exit $YF_CHECK_SIGNATURE_NO_OSSL_RSAUTIL
fi
#######################################################################################################
#                                                                                                     #
# build table of contents from provided image file                                                    #
#                                                                                                     #
#######################################################################################################
tar_create_table_of_contents "$image_file" >"$tmp/$tar_toc"
#######################################################################################################
#                                                                                                     #
# get the signature file from the image and check that it is in the expected format, before we waste  #
# a lot of time with checking an invalid signature file                                               #
#                                                                                                     #
#######################################################################################################
last_sig=0
i=0
# shellcheck disable=SC2162
while read line; do
	i=$(( i + 1 ))
	eval "$line"
	if [ "$MEMBER" = "$sig_file_name" ]; then
		last_sig=$i
	fi
done <"$tmp/$tar_toc"
if [ $last_sig -eq 0 ]; then
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized ERR_no_signature_found)" "$image_file" "$sig_file_name" 1>&2
	exit $YF_CHECK_SIGNATURE_MISSING_SIGNATURE
fi
eval "$(sed -n -e "${last_sig}p" "$tmp/$tar_toc")"
if [ "$SIZE" -eq 0 ] || [ "$SIZE" -gt 512 ]; then
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized ERR_invalid_signature_file)" "$image_file" "$sig_file_name" 1>&2
	exit $YF_CHECK_SIGNATURE_WRONG_SIGNATURE_SIZE
fi
# shellcheck disable=SC2086
tar_get_member_data "$image_file" "$sig_file_name" "$tmp/$tar_toc" >"$tmp/$sig_file_content"
fs="$(wc -c < "$tmp/$sig_file_content")"
if [ "$fs" -ne 128 ] && [ "$fs" -ne 256 ] && [ "$fs" -ne 512 ]; then # signature size for 1024-, 2048- and 4096-bit keys
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized ERR_invalid_signature_file)" "$image_file" "$sig_file_name" 1>&2
	exit $YF_CHECK_SIGNATURE_WRONG_SIGNATURE_SIZE
fi
seek_image=$(( HEADER / 512 ))
#######################################################################################################
#                                                                                                     #
# copy the specified public keys from different sources to our temporary key list                     #
#                                                                                                     #
#######################################################################################################
touch "$tmp/$public_keys_list"
while [ "$#" -gt 0 ]; do
	case "$1" in
		"-f")
			if [ -z "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_missing_file_for_option)" "-f" 1>&2
				exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
			fi
			if ! [ -f "$2" ] && ! [ -L "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_missing_file_with_list)" "$2" 1>&2
				exit $YF_CHECK_SIGNATURE_FILE_NOT_FOUND
			fi
			i=0
			# shellcheck disable=SC2162
			while read filename; do
				i=$(( i + 1 ))
				if [ -f "$filename" ]; then
					unset MOD
					unset EXP
					unset SRC
					unset DESC
					MOD=$(sed -n -e "1p" "$filename")
					if [ ${#MOD} -eq 0 ]; then
						# shellcheck disable=SC2059
						printf "$(__yf_get_localized ERR_file_read_error)" "$filename" "$i" "$2" 1>&2
						continue
					fi
					EXP=$(sed -n -e "2p" "$filename")
					[ ${#EXP} -eq 0 ] && EXP=010001
					DESC="$(printf "line %u of %s\n" "$i" "$2")"
					if ! check_modulus "$MOD"; then
						# shellcheck disable=SC2059
						printf "$(__yf_get_localized ERR_invalid_modulus)" "$i" "$2" 1>&2
						continue
					fi
					if ! is_hexadecimal "$EXP"; then
						# shellcheck disable=SC2059
						printf "$(__yf_get_localized ERR_invalid_exponent)" "$i" "$2" 1>&2
						continue
					fi
					printf "DESC=\"%s\" SRC=\"%s\" MOD=%s EXP=%s\n" "$DESC" "$filename" "$MOD" "$EXP" >>"$tmp/$public_keys_list"
				else
					# shellcheck disable=SC2059
					printf "$(__yf_get_localized ERR_file_missing_error)" "$filename" "$i" "$2" 1>&2
				fi
			done <"$2"
			shift 2
			;;
		"-b")
			if ! builtin_keys >>"$tmp/$public_keys_list"; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_no_fritzos_device)" "-b" 1>&2
				exit $YF_CHECK_SIGNATURE_NO_BUILTIN_KEYS
			fi
			shift
			;;
		"-c")
			if [ -z "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_missing_file_for_option)" "-c" 1>&2
				exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
			fi
			if ! [ -f "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_pubkey_file_missing)" "$2" "$(__yf_get_localized PART_condensed)" 1>&2
				exit $YF_CHECK_SIGNATURE_FILE_NOT_FOUND
			fi
			i=0
			# shellcheck disable=SC2162
			while read line; do
				i=$(( i + 1 ))
				unset MOD
				unset EXP
				unset SRC
				unset DESC
				MOD="$(printf "%s\n" "$line" | sed -n -e "s|.*MOD=\([0-9a-fA-F]*\).*|\1|p")"
				EXP="$(printf "%s\n" "$line" | sed -n -e "s|.*EXP=\([0-9a-fA-F]*\).*|\1|p")"
				SRC="$(printf "%s\n" "$line" | sed -n -e "s|.*SRC=\"\([^\"]*\)\".*|\1|p")"
				DESC="$(printf "%s\n" "$line" | sed -n -e "s|.*DESC=\"\([^\"]*\)\".*|\1|p")"
				if [ -z "$MOD" ]; then
					# shellcheck disable=SC2059
					printf "$(__yf_get_localized ERR_missing_modulus)" "$i" "$2" 1>&2
					exit $YF_CHECK_SIGNATURE_INVALID_DATA
				elif [ -z "$EXP" ]; then
					EXP="010001"
				fi
				if [ -z "$DESC" ]; then
					# shellcheck disable=SC2031
					[ -n "$SRC" ] && DESC="$(printf "line %u of %2\n" "$i" "$2")" || DESC="$(printf "line %u\n" "$i")"
				fi
				# shellcheck disable=SC2031
				[ -n "$SRC" ] && SRC="$(printf "%s\n" "$2")"
				if ! check_modulus "$MOD"; then
					# shellcheck disable=SC2059
					printf "$(__yf_get_localized ERR_invalid_modulus)" "$i" "$2" 1>&2
					continue
				fi
				if ! is_hexadecimal "$EXP"; then
					# shellcheck disable=SC2059
					printf "$(__yf_get_localized ERR_invalid_exponent)" "$i" "$2" 1>&2
					continue
				fi
				printf "DESC=\"%s\" SRC=\"%s\" MOD=%s EXP=%s\n" "$DESC" "$SRC" "$MOD" "$EXP" >>"$tmp/$public_keys_list"
			done <"$2"
			shift 2
			;;
		"-a")
			if [ -z "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_missing_file_for_option)" "-a" 1>&2
				exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
			fi
			if ! [ -f "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_pubkey_file_missing)" "$2" "$(__yf_get_localized PART_avmformat)" 1>&2
				exit $YF_CHECK_SIGNATURE_FILE_NOT_FOUND
			fi
			unset MOD
			unset EXP
			MOD="$(sed -n -e "1p" "$2")"
			EXP="$(sed -n -e "2p" "$2")"
			if [ ${#MOD} -gt 0 ]; then
				[ ${#EXP} -eq 0 ] && exp=010001
				if ! check_modulus "$MOD"; then
					# shellcheck disable=SC2059
					printf "$(__yf_get_localized ERR_invalid_modulus)" "1" "$2" 1>&2
					exit $YF_CHECK_SIGNATURE_INVALID_DATA
				fi
				if ! is_hexadecimal "$EXP"; then
					# shellcheck disable=SC2059
					printf "$(__yf_get_localized ERR_invalid_exponent)" "2" "$2" 1>&2
					exit $YF_CHECK_SIGNATURE_INVALID_DATA
				fi
				printf "DESC=\"text file from command line\" SRC=\"%s\" MOD=%s EXP=%s\n" "$2" "$MOD" "$EXP" >>"$tmp/$public_keys_list"
			else
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_modulus_read_error)" "$2" 1>&2
			fi
			shift 2
			;;
		"-p"|"-d")
			if [ -z "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_missing_file_for_option)" "$1" 1>&2
				exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
			fi
			[ "$1" = "-p" ] && format="PEM" || format="DER"
			if ! [ -f "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_pubkey_file_missing)" "$2" "$(printf "$(__yf_get_localized PART_pkcs1)" "$format")" 1>&2
				exit $YF_CHECK_SIGNATURE_FILE_NOT_FOUND
			fi
			pubkey_pkcs1_to_text "$2" "$format" >>"$tmp/$public_keys_list" || exit $YF_CHECK_SIGNATURE_INVALID_DATA
			shift 2
			;;
		"-s")
			if [ -n "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_too_much_arguments)" "$1" 1>&2
				exit $YF_CHECK_SIGNATURE_NO_BOX_KEY
			fi
			if ! is_fritzos_environment; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_no_fritzos_device)" "-s" 1>&2
				exit $YF_CHECK_SIGNATURE_NO_BOX_KEY
			fi
			if [ -s "$tmp/$public_keys_list" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_too_much_keys)" "-s" 1>&2
				exit $YF_CHECK_SIGNATURE_INVALID_OPTION
			fi
			if ! read_box_key >>"$tmp/$public_keys_list"; then
				rc=$?
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_read_RSA_box_key)" 1>&2
				printf "RC=%d\n" "$rc" 1>&2
				[ "$rc" -eq 1 ] && exit $YF_CHECK_SIGNATURE_NO_BOX_KEY || exit $rc
			fi
			shift
			;;
		"-e")
			if [ -z "$2" ]; then
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_missing_variable_name)" "-e" 1>&2
				exit $YF_CHECK_SIGNATURE_MISSING_ARGUMENTS
			fi
			unset MOD
			unset EXP
			MOD="$(env | sed -n -e "s|^$2=\(.*\)|\1|p")"
			EXP=010001
			if [ ${#MOD} -gt 0 ]; then
				if ! check_modulus "$MOD"; then
					# shellcheck disable=SC2059
					printf "$(__yf_get_localized ERR_invalid_modulus)" "1" "$2" 1>&2
					exit $YF_CHECK_SIGNATURE_INVALID_DATA
				fi
				printf "DESC=\"environment variable from command line\" SRC=\"%s\" MOD=%s EXP=%s\n" "$2" "$MOD" "$EXP" >>"$tmp/$public_keys_list"
			else
				# shellcheck disable=SC2059
				printf "$(__yf_get_localized ERR_missing_env_value)" "$2" 1>&2
			fi
			shift 2
			;;
		*)
			# shellcheck disable=SC2059
			printf "$(__yf_get_localized ERR_unknown_option)" "$1" 1>&2
			exit $YF_CHECK_SIGNATURE_INVALID_OPTION
			;;
	esac
done
if ! [ -s "$tmp/$public_keys_list" ]; then
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized ERR_no_public_keys)" 1>&2
	exit $YF_CHECK_SIGNATURE_NO_KEYS_DEFINED
fi
#######################################################################################################
#                                                                                                     #
# find the public key corresponding to the private key, which was used to sign the image              #
#                                                                                                     #
#######################################################################################################
[ "$YF_CHECK_SIGNATURE_SHOW_KEYS" = "1" ] && { printf "\n=== public keys collected ===\n" && cat "$tmp/$public_keys_list" && printf "=============================\n\n"; } 1>&2
# shellcheck disable=SC2059
[ "$(wc -l <"$tmp/$public_keys_list")" -gt 1 ] && printf "$(__yf_get_localized INF_probing_keys)" 1>&2
key_found=0
# shellcheck disable=SC2162
while read line; do
	eval "$line"
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized INF_public_key_check)" "$SRC" 1>&2
	modulus_to_der "$MOD" "$EXP" >"$tmp/$tmp_pubkey"
	if output="$("$YF_SIGNIMAGE_OPENSSL" rsautl -verify -pubin -inkey "$tmp/$tmp_pubkey" -keyform der -asn1parse -in "$tmp/$sig_file_content" 2>&1)"; then
		key_found=1
		show_ok
		algo=$(printf "%s\n" "$output" | sed -n -e "s|^.*OBJECT.*:\(.*\)\$|\1|p" 2>/dev/null)
		if [ ${#algo} -gt 0 ]; then
			# shellcheck disable=SC2059
			printf "$(__yf_get_localized INF_check_supported_hash)" "$algo" 1>&2
			if printf "" | "$YF_SIGNIMAGE_OPENSSL" dgst -"$algo" 2>&1 2>/dev/null 1>&2; then
				show_ok
				break
			else
				show_error
				exit $YF_CHECK_SIGNATURE_UNSUPPORTED_HASH
			fi
		else
			show_error
			exit $YF_CHECK_SIGNATURE_INVALID_SIGNATURE_DATA
		fi
	else
		show_error
	fi
done <"$tmp/$public_keys_list"
if [ $key_found -eq 0 ]; then
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized ERR_wrong_public_keys)" 1>&2
	exit $YF_CHECK_SIGNATURE_WRONG_PUBLIC_KEY
fi
#######################################################################################################
#                                                                                                     #
# now we check the signature with the openssl binary, we prepare the changed image file in a subshell #
# and pipe its output to openssl                                                                      #
#                                                                                                     #
#######################################################################################################
if ! res="$( ( "$YF_SIGNIMAGE_DD" if="$image_file" bs=512 count=$seek_image status=none 2>/dev/null;
	"$YF_SIGNIMAGE_DD" if=/dev/zero bs=512 count=2 status=none 2>/dev/null;
	"$YF_SIGNIMAGE_DD" if="$image_file" bs=512 skip=$(( seek_image + 2 )) status=none 2>/dev/null ) | \
	"$YF_SIGNIMAGE_OPENSSL" dgst -"$algo" -verify "$tmp/$tmp_pubkey" -keyform der -signature "$tmp/$sig_file_content")"; then
	# shellcheck disable=SC2059
	printf "$(__yf_get_localized ERR_verify_failed)" 1>&2
	exit $YF_CHECK_SIGNATURE_VERIFICATION_FAILED
fi
#######################################################################################################
#                                                                                                     #
# all done                                                                                            #
#                                                                                                     #
#######################################################################################################
# shellcheck disable=SC2059
printf "$(__yf_get_localized INF_verify_success)" 1>&2
exit $YF_CHECK_SIGNATURE_SUCCESS
#######################################################################################################
#                                                                                                     #
# end of file                                                                                         #
#                                                                                                     #
#######################################################################################################
